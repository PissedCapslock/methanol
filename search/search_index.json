{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Caution \ud83d\udea7 Under construction \ud83d\udea7 Methanol \u00b6 Java enjoys a neat, built-in HTTP client . However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier & more productive to work with java.net.http . You can say it's an HttClient wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know. Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze. Installation \u00b6 Gradle \u00b6 dependencies { implementation 'com.github.mizosoft.methanol:methanol:1.5.0' } Maven \u00b6 <dependencies> <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> License \u00b6 MIT","title":"Overview"},{"location":"#methanol","text":"Java enjoys a neat, built-in HTTP client . However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier & more productive to work with java.net.http . You can say it's an HttClient wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know. Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze.","title":"Methanol"},{"location":"#installation","text":"","title":"Installation"},{"location":"#gradle","text":"dependencies { implementation 'com.github.mizosoft.methanol:methanol:1.5.0' }","title":"Gradle"},{"location":"#maven","text":"<dependencies> <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol </artifactId> <version> 1.5.0 </version> </dependency> </dependencies>","title":"Maven"},{"location":"#license","text":"MIT","title":"License"},{"location":"CHANGELOG/","text":"Change Log \u00b6 Version 1.4.1 \u00b6 26-9-2020 Updated dependencies. Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers incorrectly send raw deflated bytes for the deflate encoding. Version 1.4.0 \u00b6 27-7-2020 Multipart progress tracking. Version 1.3.0 \u00b6 22-6-2020 Default read timeout in Methanol client. API for tracking upload/download progress. High-level client interceptors. Version 1.2.0 \u00b6 1-5-2020 Reactive JSON adapters with Jackson and Reactor. Common MediaType constants. XML adapters with JAXB. Version 1.1.0 \u00b6 17-4-2020 First \"main-stream\" release. Version 1.0.0 \u00b6 25-3-2020 Dummy release.","title":"Change Log"},{"location":"CHANGELOG/#change-log","text":"","title":"Change Log"},{"location":"CHANGELOG/#version-141","text":"26-9-2020 Updated dependencies. Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers incorrectly send raw deflated bytes for the deflate encoding.","title":"Version 1.4.1"},{"location":"CHANGELOG/#version-140","text":"27-7-2020 Multipart progress tracking.","title":"Version 1.4.0"},{"location":"CHANGELOG/#version-130","text":"22-6-2020 Default read timeout in Methanol client. API for tracking upload/download progress. High-level client interceptors.","title":"Version 1.3.0"},{"location":"CHANGELOG/#version-120","text":"1-5-2020 Reactive JSON adapters with Jackson and Reactor. Common MediaType constants. XML adapters with JAXB.","title":"Version 1.2.0"},{"location":"CHANGELOG/#version-110","text":"17-4-2020 First \"main-stream\" release.","title":"Version 1.1.0"},{"location":"CHANGELOG/#version-100","text":"25-3-2020 Dummy release.","title":"Version 1.0.0"},{"location":"caching/","text":"Caching \u00b6 Methanol comes with an RFC-compliant HTTP cache that supports both disk & memory storage backends. The implementation is efficient, ergonomic and bases its decisions on what's done by prominent browsers. Setup \u00b6 Specify your preferred storage backend with HttpCache.Builder then pass a cache instance to Methanol.Builder . Disk // Select a size limit that suites your application long maxSizeInBytes = 200L * 1024 * 1024 ; // 200 MBs var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // Close the cache after you're done to ensure everything is flushed to disk cache . close (); Memory // Select a size limit that suites your application long maxSizeInBytes = 50L * 1024 * 1024 ; // 50 MBs var cache = HttpCache . newBuilder () . cacheOnMemory ( maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // No need to close, but doing so avoids surprises if you later switch to disk cache . close (); Hint You can pass the builder a custom Executor for launching the asynchronous tasks needed by the cache. By default, an unbounded thread pool of non-daemon threads is used. Attention To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an IOException if it's initialized with a directory that's already in use by another instance in the same or a different JVM. Usage \u00b6 An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time & bandwidth by avoiding network use if requested resources are locally retrievable. It should be OK for modules to start using a cache-configured Methanol (and hence HttpClient ) instance as a drop-in replacement without further configuration. Normally, the cache does what's best for you if the server is properly configured to utilize client caches. Sometimes, however, you need to communicate to the cache certain conditions you want applied to the way it behaves. This is done using CacheControl . // Specify your cache directives var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 5 )) . staleWhileRevalidate ( Duration . ofMinutes ( 1 )) . build (); // Then apply to the request var request = MutableRequest . GET ( url ) . cacheControl ( cacheControl ) . toImmutableRequest (); In order to properly use CacheControl , we need to understand the key attributes of a cached response. Age \u00b6 The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the origin. Freshness \u00b6 A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime . The freshness value of a response is its freshness lifetime substracted from its age. A response is fresh if its freshness value is >= 0 . CacheControl allows you to override a response's freshness lifetime by setting the max-age directive. var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofSeconds ( 10 )) // Override the lifetime set by the server . build (); You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value. var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 10 )) // Accept a response that stays fresh for at least the next 10 minutes . build (); Info Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard & followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation & its last modification time for such responses. Staleness \u00b6 A response with a negative freshness value is said to be stale. The staleness of a stored response is simply the negation if its freshness. Normally, the cache won't serve a response with positive staleness until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like If-None-Match & If-Modified-Since , if it can serve the stale response at its disposal. If the server doesn't mind, the cache updates some metadata and serves said response without re-downloading its payload. Otherwise, the payload is re-fetched and the older entry is updated. You can let the cache tolerate some stalness so it doesn't trigger revalidation. Bounded Stalness var cacheControl = CacheControl . newBuilder () . maxStale ( Duration . ofSeconds ( 30 )) // Allow at most 30 seconds of staleness . build (); Arbitrary Staleness var cacheControl = CacheControl . newBuilder () . anyMaxStale () // Allow any staleness . build (); The stale-if-error directive makes the cache recover from revalidation errors, caused by network or server failures. The cache falls back to responses with at most the specified staleness in such occassions. var cacheControl = CacheControl . newBuilder () . staleIfError ( Duration . ofSeconds ( 30 )) . build (); No Cache \u00b6 You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what no-cache is meant for. var cacheControl = CacheControl . newBuilder () . noCache () . build (); The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed. Only If Cached \u00b6 Use only-if-cached to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, the cache immediately serves a locally generated 504 Gateway Timeout response. A perfect use-case is when network is down or the app is offline. You'd want to get a cached repsonse if it's there or otherwise nothing. var cacheControl = CacheControl . newBuilder () . onlyIfCached () . build (); Asynchronous Revalidatin \u00b6 Sometimes you need a balance between responsiveness & freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That is exactly what stale-while-revalidate does. var cacheControl = CacheControl . newBuilder () . staleWhileRevalidate ( Duration . ofMinutes ( 2 )) // Tolerate 2 minutes of staleness . build (); As usual, the cache serves stored responses if they're fresh. If a response is stale, however, it is served immediately provided it satisfies allowed staleness. What's interesting here is that an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh. Prohibiting Storage \u00b6 Use no-store if you don't want the cache to store anything about the response. var request = CacheControl . newBuilder () . noStore () . build (); Note that this, however, doesn't prohibit the cache from serving an already stored response. Invalidation \u00b6 HttpCache has APIs that give you more control over what's stored. HttpCache cache = ... // Remove the entry cached under a particular URI cache . remove ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); // Remove the response matching a particular response variant cache . remove ( MutableRequest . GET ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )) . header ( \"Accept-Encoding\" , \"gzip\" )); // Remove specific entries by examining their URIs var iterator = cache . uris (); while ( iterator . hasNext ()) { var uri = iterator . next (); if ( uri . getHost (). equals ( \"i.imgur.com\" )) { iterator . remove (); } } // Remove all entries cache . clear (); // Dispose of the cache by deleting its entrires then closing it in an atomic fashion. // The cache is rendered unusable after this call. This is meant for applications that // use a temporary directory for caching in case persistence isn't needed. cache . dispose (); Cache Operation & Statistics \u00b6 The cache is accompanied with APIs that reflect its operation & effectiveness. Cache operation typically involves 3 scenarios. Cache Hit The blessed scenario; everything was entirely served from cache and no network was used. Conditional Cache Hit The cache had to contact the origin to revalidate its copy of the response and the server decided it was valid. The cache uses server's response to update some metadata in background. Response payload isn't downloaded so network is used efficiently. Cache Miss Either the cache had no matching response or the server decided such response is too stale to be server. In both cases, the whole response is fetched from network. This is when the cache populates or updates its entries if appropriate. CacheAwareResponse \u00b6 CacheAwareResponse complements HttpResponse to better reflect cache interference. If a cache is installed, any HttpResponse<T> returned by Methanol is also a CacheAwareResponse<T> , which you can use to know which of the previous scenarios was the case. var client = Methanol . newBuilder () . cache (...) . build (); var response = ( CacheAwareResponse < String > ) client . send ( MutableRequest . GET ( url ), BodyHandlers . ofString ()); var elapsed = Duration . between ( response . timeRequestSent (), response . timeResponseReceived ()); System . out . println ( \"Time elapsed: \" + elapsed ); // networkResponse & cacheResponse are optional HttpResponses that you can further investigate var networkResponse = response . networkResponse (); var cacheResponse = response . cacheResponse (); switch ( response . cacheStatus ()) { case HIT : assertTrue ( networkResponse . isAbsent ()); assertTrue ( cacheResponse . isPresent ()); break ; case CONDITIONAL_HIT : assertTrue ( networkResponse . isPresent ()); assertTrue ( cacheResponse . isPresent ()); break ; case MISS : assertTrue ( networkResponse . isPresent ()); // cacheResponse can be absent or present break ; case LOCALLY_GENERATED : // Network was forbidden by only-if-cached but there was no valid cache response assertEquals ( HttpURLConnection . HTTP_GATEWAY_TIMEOUT , response . statusCode ()); assertTrue ( networkResponse . isAbsent ()); // cacheResponse can be absent or present break ; } HttpCache.Stats \u00b6 You can examine statistics provided by the cache to measure its effectiveness. Statistics are either global or correspond to a specific URI . Global Stats var stats = cache . status (); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); URI-specific Stats var stats = cache . stats ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); See HttpCache.Stats for all recorded statistics. Limitations \u00b6 The cache only stores responses to GETs. This is typical for most caches. Ranged content isn't supported. Requests with range-related headers are forwarded to origin and responses with 206 Partial Content aren't stored. Only the most recent response variant can be stored. Cache efficiency isn't pronounced as much if requests frequently have different values for the headers specified by Vary .","title":"Caching"},{"location":"caching/#caching","text":"Methanol comes with an RFC-compliant HTTP cache that supports both disk & memory storage backends. The implementation is efficient, ergonomic and bases its decisions on what's done by prominent browsers.","title":"Caching"},{"location":"caching/#setup","text":"Specify your preferred storage backend with HttpCache.Builder then pass a cache instance to Methanol.Builder . Disk // Select a size limit that suites your application long maxSizeInBytes = 200L * 1024 * 1024 ; // 200 MBs var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // Close the cache after you're done to ensure everything is flushed to disk cache . close (); Memory // Select a size limit that suites your application long maxSizeInBytes = 50L * 1024 * 1024 ; // 50 MBs var cache = HttpCache . newBuilder () . cacheOnMemory ( maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // No need to close, but doing so avoids surprises if you later switch to disk cache . close (); Hint You can pass the builder a custom Executor for launching the asynchronous tasks needed by the cache. By default, an unbounded thread pool of non-daemon threads is used. Attention To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an IOException if it's initialized with a directory that's already in use by another instance in the same or a different JVM.","title":"Setup"},{"location":"caching/#usage","text":"An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time & bandwidth by avoiding network use if requested resources are locally retrievable. It should be OK for modules to start using a cache-configured Methanol (and hence HttpClient ) instance as a drop-in replacement without further configuration. Normally, the cache does what's best for you if the server is properly configured to utilize client caches. Sometimes, however, you need to communicate to the cache certain conditions you want applied to the way it behaves. This is done using CacheControl . // Specify your cache directives var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 5 )) . staleWhileRevalidate ( Duration . ofMinutes ( 1 )) . build (); // Then apply to the request var request = MutableRequest . GET ( url ) . cacheControl ( cacheControl ) . toImmutableRequest (); In order to properly use CacheControl , we need to understand the key attributes of a cached response.","title":"Usage"},{"location":"caching/#age","text":"The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the origin.","title":"Age"},{"location":"caching/#freshness","text":"A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime . The freshness value of a response is its freshness lifetime substracted from its age. A response is fresh if its freshness value is >= 0 . CacheControl allows you to override a response's freshness lifetime by setting the max-age directive. var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofSeconds ( 10 )) // Override the lifetime set by the server . build (); You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value. var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 10 )) // Accept a response that stays fresh for at least the next 10 minutes . build (); Info Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard & followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation & its last modification time for such responses.","title":"Freshness"},{"location":"caching/#staleness","text":"A response with a negative freshness value is said to be stale. The staleness of a stored response is simply the negation if its freshness. Normally, the cache won't serve a response with positive staleness until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like If-None-Match & If-Modified-Since , if it can serve the stale response at its disposal. If the server doesn't mind, the cache updates some metadata and serves said response without re-downloading its payload. Otherwise, the payload is re-fetched and the older entry is updated. You can let the cache tolerate some stalness so it doesn't trigger revalidation. Bounded Stalness var cacheControl = CacheControl . newBuilder () . maxStale ( Duration . ofSeconds ( 30 )) // Allow at most 30 seconds of staleness . build (); Arbitrary Staleness var cacheControl = CacheControl . newBuilder () . anyMaxStale () // Allow any staleness . build (); The stale-if-error directive makes the cache recover from revalidation errors, caused by network or server failures. The cache falls back to responses with at most the specified staleness in such occassions. var cacheControl = CacheControl . newBuilder () . staleIfError ( Duration . ofSeconds ( 30 )) . build ();","title":"Staleness"},{"location":"caching/#no-cache","text":"You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what no-cache is meant for. var cacheControl = CacheControl . newBuilder () . noCache () . build (); The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed.","title":"No Cache"},{"location":"caching/#only-if-cached","text":"Use only-if-cached to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, the cache immediately serves a locally generated 504 Gateway Timeout response. A perfect use-case is when network is down or the app is offline. You'd want to get a cached repsonse if it's there or otherwise nothing. var cacheControl = CacheControl . newBuilder () . onlyIfCached () . build ();","title":"Only If Cached"},{"location":"caching/#asynchronous-revalidatin","text":"Sometimes you need a balance between responsiveness & freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That is exactly what stale-while-revalidate does. var cacheControl = CacheControl . newBuilder () . staleWhileRevalidate ( Duration . ofMinutes ( 2 )) // Tolerate 2 minutes of staleness . build (); As usual, the cache serves stored responses if they're fresh. If a response is stale, however, it is served immediately provided it satisfies allowed staleness. What's interesting here is that an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh.","title":"Asynchronous Revalidatin"},{"location":"caching/#prohibiting-storage","text":"Use no-store if you don't want the cache to store anything about the response. var request = CacheControl . newBuilder () . noStore () . build (); Note that this, however, doesn't prohibit the cache from serving an already stored response.","title":"Prohibiting Storage"},{"location":"caching/#invalidation","text":"HttpCache has APIs that give you more control over what's stored. HttpCache cache = ... // Remove the entry cached under a particular URI cache . remove ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); // Remove the response matching a particular response variant cache . remove ( MutableRequest . GET ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )) . header ( \"Accept-Encoding\" , \"gzip\" )); // Remove specific entries by examining their URIs var iterator = cache . uris (); while ( iterator . hasNext ()) { var uri = iterator . next (); if ( uri . getHost (). equals ( \"i.imgur.com\" )) { iterator . remove (); } } // Remove all entries cache . clear (); // Dispose of the cache by deleting its entrires then closing it in an atomic fashion. // The cache is rendered unusable after this call. This is meant for applications that // use a temporary directory for caching in case persistence isn't needed. cache . dispose ();","title":"Invalidation"},{"location":"caching/#cache-operation-statistics","text":"The cache is accompanied with APIs that reflect its operation & effectiveness. Cache operation typically involves 3 scenarios. Cache Hit The blessed scenario; everything was entirely served from cache and no network was used. Conditional Cache Hit The cache had to contact the origin to revalidate its copy of the response and the server decided it was valid. The cache uses server's response to update some metadata in background. Response payload isn't downloaded so network is used efficiently. Cache Miss Either the cache had no matching response or the server decided such response is too stale to be server. In both cases, the whole response is fetched from network. This is when the cache populates or updates its entries if appropriate.","title":"Cache Operation &amp; Statistics"},{"location":"caching/#cacheawareresponse","text":"CacheAwareResponse complements HttpResponse to better reflect cache interference. If a cache is installed, any HttpResponse<T> returned by Methanol is also a CacheAwareResponse<T> , which you can use to know which of the previous scenarios was the case. var client = Methanol . newBuilder () . cache (...) . build (); var response = ( CacheAwareResponse < String > ) client . send ( MutableRequest . GET ( url ), BodyHandlers . ofString ()); var elapsed = Duration . between ( response . timeRequestSent (), response . timeResponseReceived ()); System . out . println ( \"Time elapsed: \" + elapsed ); // networkResponse & cacheResponse are optional HttpResponses that you can further investigate var networkResponse = response . networkResponse (); var cacheResponse = response . cacheResponse (); switch ( response . cacheStatus ()) { case HIT : assertTrue ( networkResponse . isAbsent ()); assertTrue ( cacheResponse . isPresent ()); break ; case CONDITIONAL_HIT : assertTrue ( networkResponse . isPresent ()); assertTrue ( cacheResponse . isPresent ()); break ; case MISS : assertTrue ( networkResponse . isPresent ()); // cacheResponse can be absent or present break ; case LOCALLY_GENERATED : // Network was forbidden by only-if-cached but there was no valid cache response assertEquals ( HttpURLConnection . HTTP_GATEWAY_TIMEOUT , response . statusCode ()); assertTrue ( networkResponse . isAbsent ()); // cacheResponse can be absent or present break ; }","title":"CacheAwareResponse"},{"location":"caching/#httpcachestats","text":"You can examine statistics provided by the cache to measure its effectiveness. Statistics are either global or correspond to a specific URI . Global Stats var stats = cache . status (); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); URI-specific Stats var stats = cache . stats ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); See HttpCache.Stats for all recorded statistics.","title":"HttpCache.Stats"},{"location":"caching/#limitations","text":"The cache only stores responses to GETs. This is typical for most caches. Ranged content isn't supported. Requests with range-related headers are forwarded to origin and responses with 206 Partial Content aren't stored. Only the most recent response variant can be stored. Cache efficiency isn't pronounced as much if requests frequently have different values for the headers specified by Vary .","title":"Limitations"},{"location":"interceptors/","text":"Interceptors \u00b6 Interceptors allow you to inspect, mutate, retry and short-circuit request/response exchanges. Together, interceptors build an invocation chain that can apply capable transformations to requests moving forward and to responses in their way back. Writing Interceptors \u00b6 Interceptors sit between a Methanol client and its underlying HttpClient , referred to as its backend. When registered, an interceptor is invoked each send or sendAsync call. Here's an interceptor that logs blocking and asynchronous exchanges. public final class LoggingInterceptor implements Methanol . Interceptor { private static final Logger LOGGER = Logger . getLogger ( LoggingInterceptor . class . getName ()); @Override public < T > HttpResponse < T > intercept ( HttpRequest request , Chain < T > chain ) throws IOException , InterruptedException { logRequest ( request ); return toLoggingChain ( request , chain ). forward ( request ); } @Override public < T > CompletableFuture < HttpResponse < T >> interceptAsync ( HttpRequest request , Chain < T > chain ) { logRequest ( request ); return toLoggingChain ( request , chain ). forwardAsync ( request ); } private static void logRequest ( HttpRequest request ) { LOGGER . info (() -> String . format ( \"Sending %s%n%s\" , request , headersToString ( request . headers ()))); } private static < T > Chain < T > toLoggingChain ( HttpRequest request , Chain < T > chain ) { var sentAt = Instant . now (); return chain . withBodyHandler ( responseInfo -> { LOGGER . info (() -> String . format ( \"Completed %s %s with %d in %sms%n%s\" , request . method (), request . uri (), responseInfo . statusCode (), Duration . between ( sentAt , Instant . now ()). toMillis (), headersToString ( responseInfo . headers ()))); // Apply the original BodyHandler return chain . bodyHandler (). apply ( responseInfo ); }); } private static String headersToString ( HttpHeaders headers ) { return headers . map (). entrySet (). stream () . map ( entry -> entry . getKey () + \": \" + String . join ( \", \" , entry . getValue ())) . collect ( Collectors . joining ( System . lineSeparator ())); } } HttpClient has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a Chain<T> so it can forward requests to its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's forward or forwardAsync after it has done its job. If your interceptor only modifies requests, prefer passing a lambda to Interceptor::create to implementing Interceptor . // Enable Expect: continue for all POSTs to a particular host var expectContinueInterceptor = Interceptor . create ( request -> request . method (). equalsIgnoreCase ( \"POST\" ) && request . uri (). getHost (). equals ( \"api.imgur.com\" ) ? MutableRequest . copyOf ( request ). expectContinue ( true ) : request ); Intercepting Bodies \u00b6 A powerful property of interceptors is their control over how responses are returned to their caller. Before it forwards the request, an interceptor can transform its chain's BodyHandler using Chain::withBodyHandler . A transformed BodyHandler typically applies the handler the chain previously had, then wraps the resulted BodySubscriber , so it intercepts the response body as it's being received by the caller. This opens the door for interesting things like transparently decrypting a response or computing its digest. This is how Methanol does transparent decompression & cache writes. Note that this applies to requests too. You can transform a request body by wrapping its BodyPublisher , if it's got any. BodyPublisher & BodySubscriber APIs can be nicely layered to apply different transformations. Invocation Order \u00b6 An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and Methanol 's internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between Methanol and its backend HttpClient . They get invoked right before the request gets sent. This has a number of implications. Client Interceptors \u00b6 See the request just as received from the application. Their transformed BodyHandler receives the response body after the client applies its decompressing & cache writing handlers. Backend Interceptors \u00b6 Observe the request after the client applies things like the base URI and default headers. Additionally, they see intermediate headers added by the client or the cache like Accept-Encoding & If-None-Math . Receive the response body just as transmitted by the backend. For instance, a transformed BodyHandler receives a compressed body if the response comes with a Content-Encoding header. May not always be invoked. This is the case when a cache decides it doesn't need network and hence doesn't proceed the call to the backend. Attention If a cache is installed, Methanol does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors are invoked more than once when requests are redirected in the presence of a cache. Short-circuiting \u00b6 Both client & backend interceptors can refrain from forwarding the request. They're allowed to short-circuit a request's path to the backend by returning a fabricated response. This makes them good candidates for testing. Mock responses with client interceptors to investigate requests just as sent by your application. Mock responses with backend interceptors to explore requests as they get handed to the backend. This makes backend interceptors perfect for testing how your application interacts with the cache. Registration \u00b6 You register client interceptors with the builder using interceptor(...) . Similarly, backend interceptors are registered with backendInterceptor(...) . Interceptors in each group get invoked in registration order. Client Interceptors var client = Methanol . newBuilder () . interceptor ( new LoggingInterceptor ()) . build (); Backend Interceptors var client = Methanol . newBuilder () . backendInterceptor ( new LoggingInterceptor ()) . build (); Limitations \u00b6 Remember that Methanol is built atop a standard HttpClient , which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because HttpClient exports no API to do so. If you're coming from places like Apache HttpClient or OkHttp, there's no support for the fully fledged network interceptors available there.","title":"Interceptors"},{"location":"interceptors/#interceptors","text":"Interceptors allow you to inspect, mutate, retry and short-circuit request/response exchanges. Together, interceptors build an invocation chain that can apply capable transformations to requests moving forward and to responses in their way back.","title":"Interceptors"},{"location":"interceptors/#writing-interceptors","text":"Interceptors sit between a Methanol client and its underlying HttpClient , referred to as its backend. When registered, an interceptor is invoked each send or sendAsync call. Here's an interceptor that logs blocking and asynchronous exchanges. public final class LoggingInterceptor implements Methanol . Interceptor { private static final Logger LOGGER = Logger . getLogger ( LoggingInterceptor . class . getName ()); @Override public < T > HttpResponse < T > intercept ( HttpRequest request , Chain < T > chain ) throws IOException , InterruptedException { logRequest ( request ); return toLoggingChain ( request , chain ). forward ( request ); } @Override public < T > CompletableFuture < HttpResponse < T >> interceptAsync ( HttpRequest request , Chain < T > chain ) { logRequest ( request ); return toLoggingChain ( request , chain ). forwardAsync ( request ); } private static void logRequest ( HttpRequest request ) { LOGGER . info (() -> String . format ( \"Sending %s%n%s\" , request , headersToString ( request . headers ()))); } private static < T > Chain < T > toLoggingChain ( HttpRequest request , Chain < T > chain ) { var sentAt = Instant . now (); return chain . withBodyHandler ( responseInfo -> { LOGGER . info (() -> String . format ( \"Completed %s %s with %d in %sms%n%s\" , request . method (), request . uri (), responseInfo . statusCode (), Duration . between ( sentAt , Instant . now ()). toMillis (), headersToString ( responseInfo . headers ()))); // Apply the original BodyHandler return chain . bodyHandler (). apply ( responseInfo ); }); } private static String headersToString ( HttpHeaders headers ) { return headers . map (). entrySet (). stream () . map ( entry -> entry . getKey () + \": \" + String . join ( \", \" , entry . getValue ())) . collect ( Collectors . joining ( System . lineSeparator ())); } } HttpClient has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a Chain<T> so it can forward requests to its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's forward or forwardAsync after it has done its job. If your interceptor only modifies requests, prefer passing a lambda to Interceptor::create to implementing Interceptor . // Enable Expect: continue for all POSTs to a particular host var expectContinueInterceptor = Interceptor . create ( request -> request . method (). equalsIgnoreCase ( \"POST\" ) && request . uri (). getHost (). equals ( \"api.imgur.com\" ) ? MutableRequest . copyOf ( request ). expectContinue ( true ) : request );","title":"Writing Interceptors"},{"location":"interceptors/#intercepting-bodies","text":"A powerful property of interceptors is their control over how responses are returned to their caller. Before it forwards the request, an interceptor can transform its chain's BodyHandler using Chain::withBodyHandler . A transformed BodyHandler typically applies the handler the chain previously had, then wraps the resulted BodySubscriber , so it intercepts the response body as it's being received by the caller. This opens the door for interesting things like transparently decrypting a response or computing its digest. This is how Methanol does transparent decompression & cache writes. Note that this applies to requests too. You can transform a request body by wrapping its BodyPublisher , if it's got any. BodyPublisher & BodySubscriber APIs can be nicely layered to apply different transformations.","title":"Intercepting Bodies"},{"location":"interceptors/#invocation-order","text":"An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and Methanol 's internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between Methanol and its backend HttpClient . They get invoked right before the request gets sent. This has a number of implications.","title":"Invocation Order"},{"location":"interceptors/#client-interceptors","text":"See the request just as received from the application. Their transformed BodyHandler receives the response body after the client applies its decompressing & cache writing handlers.","title":"Client Interceptors"},{"location":"interceptors/#backend-interceptors","text":"Observe the request after the client applies things like the base URI and default headers. Additionally, they see intermediate headers added by the client or the cache like Accept-Encoding & If-None-Math . Receive the response body just as transmitted by the backend. For instance, a transformed BodyHandler receives a compressed body if the response comes with a Content-Encoding header. May not always be invoked. This is the case when a cache decides it doesn't need network and hence doesn't proceed the call to the backend. Attention If a cache is installed, Methanol does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors are invoked more than once when requests are redirected in the presence of a cache.","title":"Backend Interceptors"},{"location":"interceptors/#short-circuiting","text":"Both client & backend interceptors can refrain from forwarding the request. They're allowed to short-circuit a request's path to the backend by returning a fabricated response. This makes them good candidates for testing. Mock responses with client interceptors to investigate requests just as sent by your application. Mock responses with backend interceptors to explore requests as they get handed to the backend. This makes backend interceptors perfect for testing how your application interacts with the cache.","title":"Short-circuiting"},{"location":"interceptors/#registration","text":"You register client interceptors with the builder using interceptor(...) . Similarly, backend interceptors are registered with backendInterceptor(...) . Interceptors in each group get invoked in registration order. Client Interceptors var client = Methanol . newBuilder () . interceptor ( new LoggingInterceptor ()) . build (); Backend Interceptors var client = Methanol . newBuilder () . backendInterceptor ( new LoggingInterceptor ()) . build ();","title":"Registration"},{"location":"interceptors/#limitations","text":"Remember that Methanol is built atop a standard HttpClient , which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because HttpClient exports no API to do so. If you're coming from places like Apache HttpClient or OkHttp, there's no support for the fully fledged network interceptors available there.","title":"Limitations"},{"location":"interruptible_reading/","text":"Interruptible Reading \u00b6 Reading from blocking sources like InputStreams isn't always avoidable. Once they're needed, JDK's BodyHandlers::ofInputStream can be used to obtain an HttpResponse<InputStream> . However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels . These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore. MoreBodySubscibers has interruptible ReadableByteChannel and Reader implementations. Use JDK's Channels::newInputStream to get an InputStream from an interruptible ReadableByteChannel when input streams is what you need. Example - Interruptible Body Processing \u00b6 Here's an example of a hypothetical component that processes the response from a ReadableByteChannel . When the task is to be discarded, reader threads are interrupted by shutting down the owning ExecutorService . This closes open channels and instructs them to halt blocking reads. class BodyProcessor { final ExecutorService executorService = Executors . newCachedThreadPool (); final Methanol client = Methanol . create (); CompletableFuture < Void > processAsync ( HttpRequest request , Consumer < ByteBuffer > processAction ) { return client . sendAsync ( request , MoreBodyHandlers . ofByteChannel ()) . thenApplyAsync ( res -> { var buffer = ByteBuffer . allocate ( 8 * 1024 ); try ( var channel = res . body ()) { while ( channel . read ( buffer . clear ()) >= 0 ) { processAction . accept ( buffer . flip ()); } } catch ( ClosedByInterruptException | ClosedChannelException ignored ) { // The thread was interrupted due to ExecutorService shutdown } catch ( IOException e ) { throw new UncheckedIOException ( e ); } return null ; }, executorService ); } void terminate () { executorService . shutdownNow (); } }","title":"Interruptible Reading"},{"location":"interruptible_reading/#interruptible-reading","text":"Reading from blocking sources like InputStreams isn't always avoidable. Once they're needed, JDK's BodyHandlers::ofInputStream can be used to obtain an HttpResponse<InputStream> . However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels . These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore. MoreBodySubscibers has interruptible ReadableByteChannel and Reader implementations. Use JDK's Channels::newInputStream to get an InputStream from an interruptible ReadableByteChannel when input streams is what you need.","title":"Interruptible Reading"},{"location":"interruptible_reading/#example-interruptible-body-processing","text":"Here's an example of a hypothetical component that processes the response from a ReadableByteChannel . When the task is to be discarded, reader threads are interrupted by shutting down the owning ExecutorService . This closes open channels and instructs them to halt blocking reads. class BodyProcessor { final ExecutorService executorService = Executors . newCachedThreadPool (); final Methanol client = Methanol . create (); CompletableFuture < Void > processAsync ( HttpRequest request , Consumer < ByteBuffer > processAction ) { return client . sendAsync ( request , MoreBodyHandlers . ofByteChannel ()) . thenApplyAsync ( res -> { var buffer = ByteBuffer . allocate ( 8 * 1024 ); try ( var channel = res . body ()) { while ( channel . read ( buffer . clear ()) >= 0 ) { processAction . accept ( buffer . flip ()); } } catch ( ClosedByInterruptException | ClosedChannelException ignored ) { // The thread was interrupted due to ExecutorService shutdown } catch ( IOException e ) { throw new UncheckedIOException ( e ); } return null ; }, executorService ); } void terminate () { executorService . shutdownNow (); } }","title":"Example - Interruptible Body Processing"},{"location":"object_mapping/","text":"Object Mapping \u00b6 HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available BodyPublisher & BodySubscriber implementations are too basic, and implementing your own can be very tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies. Setup \u00b6 Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules. methanol-gson : JSON with Gson methanol-jackson : JSON with Jackson methanol-jackson-flux : Reactive JSON with Jackson and Reactor methanol-protobuf : Google's Protocol Buffers methanol-jaxb : XML with JAXB Adapters are dynamically located using Java's java.util.ServiceLoader . You can find clear installation steps in each module's README. We'll later see how to implement custom adapters as well. If you want to run examples presented here, get started by installing your favorite JSON adapter! Receiving Objects \u00b6 To get an HttpResponse<T> , give MoreBodyHandlers a T.class and it'll give you a BodyHandler<T> in return. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofObject ( GitHubUser . class )); return response . body (); } public static final class GitHubUser { public String login ; public long id ; public String url ; ... } If you want to get fancier with generics, use a TypeRef<T> . List < GitHubIssue > getIssuesForRepo ( String owner , String repo ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"repos/\" + owner + \"/\" + repo \"/issues\" ); var response = client . send ( request , MoreBodyHandlers . ofObject ( new TypeRef < List < GitHubIssue >> () {})); return response . body (); } public static final class GitHubIssue { public String title ; public GitHubUser user ; public String body ; ... } The right adapter is selected based on the response's Content-Type . For instance, a response with Content-Type: application/json will cause Methanol to look for a JSON adapter. If such lookup fails, an UnsupportedOperationException is thrown. Sending Objects \u00b6 Get a BodyPubilsher for whatever object you've got by passing it in along with a MediaType describing which adapter you prefer selected. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . build (); String renderMarkdown ( RenderRequest renderRequest ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( renderRequest , MediaType . APPLICATION_JSON ); var request = MutableRequest . POST ( \"/user/\" + username , requestBody ) . header ( \"Accept\" , \"application/html\" ); var response = client . send ( request , BodyHandlers . ofString ()); return response . body (); } public static final class RenderRequest { public String text ; public String mode ; public String context ; ... } Adapters \u00b6 An adapter provides Encoder and/or Decoder implementations. Both interfaces implement BodyAdapter , which defines the methods necessary for Methanol to know which object types the adapter believes it can handle, and in what scheme. An Encoder creates a BodyPublisher that streams a given object's serialized form. Similarly, a Decoder supplies BodySubscriber<T> instances for a given TypeRef<T> that convert the response body into T . An optional MediaType is passed to encoders & decoders in order to further describe the desired mapping scheme (e.g. specify a character set). Example - An HTML Adapter \u00b6 Here's an adapter that uses Jsoup to convert HTML bodies to parsed Document objects and vise versa. When you're writing adapters, extend from AbstractBodyAdapter to get free media type matching & other helpful functions. public abstract class JsoupAdapter extends AbstractBodyAdapter implements BodyAdapter { JsoupAdapter () { super ( MediaType . TEXT_HTML ); } @Override public boolean supportsType ( TypeRef <?> type ) { return type . rawType () == Document . class ; } public static final class Decoder extends JsoupAdapter implements BodyAdapter . Decoder { @Override public < T > BodySubscriber < T > toObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var subscriber = BodySubscribers . mapping ( BodySubscribers . ofString ( charset ), Jsoup :: parse ); return BodySubscribers . mapping ( subscriber , type . exactRawType ():: cast ); // Safely cast Document to T } } public static final class Encoder extends JsoupAdapter implements BodyAdapter . Encoder { @Override public BodyPublisher toBody ( Object object , @Nullable MediaType mediaType ) { requireSupport ( object . getClass ()); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); return BodyPublishers . ofString ((( Document ) object ). outerHtml (), charset ); } } } Registration \u00b6 Declare your encoder & decoder implementations as service-providers in the manner specified by Java's ServiceLoader . Here's the appropriate provider declarations for our Jsoup adapter to put in module-info.java . module my . module { ... provides BodyAdapter . Decoder with JsoupAdapter . Decoder ; provides BodyAdapter . Encoder with JsoupAdapter . Encoder ; } Usage \u00b6 Now Methanol can send and receive HTML Documents ! final Methanol client = Methanol . create (); HttpResponse < Document > downloadHtml ( String url ) IOException , InterruptedException { var request = MutableRequest . GET ( url ) . header ( \"Accept\" , \"application/html\" ); return client . send ( request , MoreBodyHandlers . ofObject ( Document . class )); } < T > HttpResponse < T > uploadHtml ( String url , Document htmlDoc , BodyHandler < T > responseHandler ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( htmlDoc , MediaType . TEXT_HTML ); var request = MutableRequest . POST ( url , requestBody ); return client . send ( request , responseHandler ); } Buffering vs Streaming \u00b6 MoreBodyHandlers::ofObject creates handlers that use MoreBodySubscribers::ofObject to obtain the appropriate BodySubscriber<T> . Such subscriber typically buffers the whole response body in memory then decodes from there. This might not be ideal for you if your responses tend to have large bodies or you'd prefer the memory efficiency afforded by decoding from a streaming source. If that fits you, MoreBodyHandlers::ofDeferredObject is the way to go. GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofDeferredObject ( GitHubUser . class )); HttpStatus . requireSuccessful ( response ); return response . body (). get (); } Such handler results in an HttpResponse<Supplier<T>> . The response is completed as soon as all headers are read. If the chosen decoder's toDeferredObject is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an InputStream or a Reader . The Decoder interface has a naive default implementation for toDeferredObject that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder. @Override public < T > BodySubscriber < Supplier < T >> toDeferredObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); BodySubscriber < Supplier < Document >> subscriber = BodySubscribers . mapping ( MoreBodySubscribers . ofReader ( charset ), reader -> () -> Parser . htmlParser (). parseInput ( reader , \"\" )); // Note the deferred parsing return BodySubscribers . mapping ( subscriber , supplier -> () -> type . exactRawType (). cast ( supplier . get ())); // Safely cast Document to T }","title":"Object Mapping"},{"location":"object_mapping/#object-mapping","text":"HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available BodyPublisher & BodySubscriber implementations are too basic, and implementing your own can be very tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies.","title":"Object Mapping"},{"location":"object_mapping/#setup","text":"Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules. methanol-gson : JSON with Gson methanol-jackson : JSON with Jackson methanol-jackson-flux : Reactive JSON with Jackson and Reactor methanol-protobuf : Google's Protocol Buffers methanol-jaxb : XML with JAXB Adapters are dynamically located using Java's java.util.ServiceLoader . You can find clear installation steps in each module's README. We'll later see how to implement custom adapters as well. If you want to run examples presented here, get started by installing your favorite JSON adapter!","title":"Setup"},{"location":"object_mapping/#receiving-objects","text":"To get an HttpResponse<T> , give MoreBodyHandlers a T.class and it'll give you a BodyHandler<T> in return. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofObject ( GitHubUser . class )); return response . body (); } public static final class GitHubUser { public String login ; public long id ; public String url ; ... } If you want to get fancier with generics, use a TypeRef<T> . List < GitHubIssue > getIssuesForRepo ( String owner , String repo ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"repos/\" + owner + \"/\" + repo \"/issues\" ); var response = client . send ( request , MoreBodyHandlers . ofObject ( new TypeRef < List < GitHubIssue >> () {})); return response . body (); } public static final class GitHubIssue { public String title ; public GitHubUser user ; public String body ; ... } The right adapter is selected based on the response's Content-Type . For instance, a response with Content-Type: application/json will cause Methanol to look for a JSON adapter. If such lookup fails, an UnsupportedOperationException is thrown.","title":"Receiving Objects"},{"location":"object_mapping/#sending-objects","text":"Get a BodyPubilsher for whatever object you've got by passing it in along with a MediaType describing which adapter you prefer selected. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . build (); String renderMarkdown ( RenderRequest renderRequest ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( renderRequest , MediaType . APPLICATION_JSON ); var request = MutableRequest . POST ( \"/user/\" + username , requestBody ) . header ( \"Accept\" , \"application/html\" ); var response = client . send ( request , BodyHandlers . ofString ()); return response . body (); } public static final class RenderRequest { public String text ; public String mode ; public String context ; ... }","title":"Sending Objects"},{"location":"object_mapping/#adapters","text":"An adapter provides Encoder and/or Decoder implementations. Both interfaces implement BodyAdapter , which defines the methods necessary for Methanol to know which object types the adapter believes it can handle, and in what scheme. An Encoder creates a BodyPublisher that streams a given object's serialized form. Similarly, a Decoder supplies BodySubscriber<T> instances for a given TypeRef<T> that convert the response body into T . An optional MediaType is passed to encoders & decoders in order to further describe the desired mapping scheme (e.g. specify a character set).","title":"Adapters"},{"location":"object_mapping/#example-an-html-adapter","text":"Here's an adapter that uses Jsoup to convert HTML bodies to parsed Document objects and vise versa. When you're writing adapters, extend from AbstractBodyAdapter to get free media type matching & other helpful functions. public abstract class JsoupAdapter extends AbstractBodyAdapter implements BodyAdapter { JsoupAdapter () { super ( MediaType . TEXT_HTML ); } @Override public boolean supportsType ( TypeRef <?> type ) { return type . rawType () == Document . class ; } public static final class Decoder extends JsoupAdapter implements BodyAdapter . Decoder { @Override public < T > BodySubscriber < T > toObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var subscriber = BodySubscribers . mapping ( BodySubscribers . ofString ( charset ), Jsoup :: parse ); return BodySubscribers . mapping ( subscriber , type . exactRawType ():: cast ); // Safely cast Document to T } } public static final class Encoder extends JsoupAdapter implements BodyAdapter . Encoder { @Override public BodyPublisher toBody ( Object object , @Nullable MediaType mediaType ) { requireSupport ( object . getClass ()); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); return BodyPublishers . ofString ((( Document ) object ). outerHtml (), charset ); } } }","title":"Example - An HTML Adapter"},{"location":"object_mapping/#registration","text":"Declare your encoder & decoder implementations as service-providers in the manner specified by Java's ServiceLoader . Here's the appropriate provider declarations for our Jsoup adapter to put in module-info.java . module my . module { ... provides BodyAdapter . Decoder with JsoupAdapter . Decoder ; provides BodyAdapter . Encoder with JsoupAdapter . Encoder ; }","title":"Registration"},{"location":"object_mapping/#usage","text":"Now Methanol can send and receive HTML Documents ! final Methanol client = Methanol . create (); HttpResponse < Document > downloadHtml ( String url ) IOException , InterruptedException { var request = MutableRequest . GET ( url ) . header ( \"Accept\" , \"application/html\" ); return client . send ( request , MoreBodyHandlers . ofObject ( Document . class )); } < T > HttpResponse < T > uploadHtml ( String url , Document htmlDoc , BodyHandler < T > responseHandler ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( htmlDoc , MediaType . TEXT_HTML ); var request = MutableRequest . POST ( url , requestBody ); return client . send ( request , responseHandler ); }","title":"Usage"},{"location":"object_mapping/#buffering-vs-streaming","text":"MoreBodyHandlers::ofObject creates handlers that use MoreBodySubscribers::ofObject to obtain the appropriate BodySubscriber<T> . Such subscriber typically buffers the whole response body in memory then decodes from there. This might not be ideal for you if your responses tend to have large bodies or you'd prefer the memory efficiency afforded by decoding from a streaming source. If that fits you, MoreBodyHandlers::ofDeferredObject is the way to go. GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofDeferredObject ( GitHubUser . class )); HttpStatus . requireSuccessful ( response ); return response . body (). get (); } Such handler results in an HttpResponse<Supplier<T>> . The response is completed as soon as all headers are read. If the chosen decoder's toDeferredObject is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an InputStream or a Reader . The Decoder interface has a naive default implementation for toDeferredObject that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder. @Override public < T > BodySubscriber < Supplier < T >> toDeferredObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); BodySubscriber < Supplier < Document >> subscriber = BodySubscribers . mapping ( MoreBodySubscribers . ofReader ( charset ), reader -> () -> Parser . htmlParser (). parseInput ( reader , \"\" )); // Note the deferred parsing return BodySubscribers . mapping ( subscriber , supplier -> () -> type . exactRawType (). cast ( supplier . get ())); // Safely cast Document to T }","title":"Buffering vs Streaming"},{"location":"writablebodypublisher/","text":"WritableBodyPublisher \u00b6 Not all APIs play well with non-blocking sources like BodyPublisher . Many only support writing into a blocking sink like an OutputStream or a Reader . Using such APIs is made easier with WritableBodyPublisher , which allows you to stream the request body through an OutputStream or a WritableByteChannel , possibly asynchronously. Example - Gzipped Uploads \u00b6 Let's say your sever supports compressed requests, and you want your file uploads to be faster, so you compress the request body with gzip. final Methanol client = Methanol . create (); CompletableFuture < HttpResponse < Void >> postAsync ( Path file ) { var requestBody = WritableBodyPublisher . create (); var request = MutableRequest . POST ( \"https://example.com\" , requestBody ) . header ( \"Content-Encoding\" , \"gzip\" ); CompletableFuture . runAsync (() -> { try ( var gzipOut = new GZIPOutputStream ( requestBody . outputStream ())) { Files . copy ( file , gzipOut ); } catch ( IOException ioe ) { requestBody . closeExceptionally ( ioe ); } }); return client . sendAsync ( request , BodyHandlers . discarding ()); } WritableBodyPublisher acts as a pipe which connects OutputStream and BodyPublisher backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use WritableBodyPublisher::flush to make any buffered content available for consumption. After you're done writing, call close() or closeExceptionally(Throwable) to complete the request either normally or exceptionally.","title":"WritableBodyPublisher"},{"location":"writablebodypublisher/#writablebodypublisher","text":"Not all APIs play well with non-blocking sources like BodyPublisher . Many only support writing into a blocking sink like an OutputStream or a Reader . Using such APIs is made easier with WritableBodyPublisher , which allows you to stream the request body through an OutputStream or a WritableByteChannel , possibly asynchronously.","title":"WritableBodyPublisher"},{"location":"writablebodypublisher/#example-gzipped-uploads","text":"Let's say your sever supports compressed requests, and you want your file uploads to be faster, so you compress the request body with gzip. final Methanol client = Methanol . create (); CompletableFuture < HttpResponse < Void >> postAsync ( Path file ) { var requestBody = WritableBodyPublisher . create (); var request = MutableRequest . POST ( \"https://example.com\" , requestBody ) . header ( \"Content-Encoding\" , \"gzip\" ); CompletableFuture . runAsync (() -> { try ( var gzipOut = new GZIPOutputStream ( requestBody . outputStream ())) { Files . copy ( file , gzipOut ); } catch ( IOException ioe ) { requestBody . closeExceptionally ( ioe ); } }); return client . sendAsync ( request , BodyHandlers . discarding ()); } WritableBodyPublisher acts as a pipe which connects OutputStream and BodyPublisher backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use WritableBodyPublisher::flush to make any buffered content available for consumption. After you're done writing, call close() or closeExceptionally(Throwable) to complete the request either normally or exceptionally.","title":"Example - Gzipped Uploads"}]}