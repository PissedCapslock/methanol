{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Caution \ud83d\udea7 Under construction \ud83d\udea7 Methanol \u00b6 Java enjoys a neat, built-in HTTP client . However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier & more productive to work with java.net.http . You can say it's an HttClient wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know. Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze. Installation \u00b6 Gradle \u00b6 dependencies { implementation 'com.github.mizosoft.methanol:methanol:1.5.0' } Maven \u00b6 <dependencies> <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol </artifactId> <version> 1.5.0 </version> </dependency> </dependencies> License \u00b6 MIT","title":"Overview"},{"location":"#methanol","text":"Java enjoys a neat, built-in HTTP client . However, it lacks key HTTP features like multipart uploads, caching and response decompression. Methanol comes in to fill these gaps. The library comprises a set of lightweight, yet powerful extensions aimed at making it much easier & more productive to work with java.net.http . You can say it's an HttClient wrapper, but you'll see it almost seamlessly integrates with the standard API you might already know. Methanol isn't invasive. The core library has zero runtime dependencies. However, special attention is given to object mapping, so integration with libraries like Jackson or Gson becomes a breeze.","title":"Methanol"},{"location":"#installation","text":"","title":"Installation"},{"location":"#gradle","text":"dependencies { implementation 'com.github.mizosoft.methanol:methanol:1.5.0' }","title":"Gradle"},{"location":"#maven","text":"<dependencies> <dependency> <groupId> com.github.mizosoft.methanol </groupId> <artifactId> methanol </artifactId> <version> 1.5.0 </version> </dependency> </dependencies>","title":"Maven"},{"location":"#license","text":"MIT","title":"License"},{"location":"CHANGELOG/","text":"Change Log \u00b6 Version 1.4.1 \u00b6 26-9-2020 Updated dependencies. Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers incorrectly send raw deflated bytes for the deflate encoding. Version 1.4.0 \u00b6 27-7-2020 Multipart progress tracking. Version 1.3.0 \u00b6 22-6-2020 Default read timeout in Methanol client. API for tracking upload/download progress. High-level client interceptors. Version 1.2.0 \u00b6 1-5-2020 Reactive JSON adapters with Jackson and Reactor. Common MediaType constants. XML adapters with JAXB. Version 1.1.0 \u00b6 17-4-2020 First \"main-stream\" release. Version 1.0.0 \u00b6 25-3-2020 Dummy release.","title":"Change Log"},{"location":"CHANGELOG/#change-log","text":"","title":"Change Log"},{"location":"CHANGELOG/#version-141","text":"26-9-2020 Updated dependencies. Fix: Autodetect if a deflated stream is zlib-wrapped or not to not crash when some servers incorrectly send raw deflated bytes for the deflate encoding.","title":"Version 1.4.1"},{"location":"CHANGELOG/#version-140","text":"27-7-2020 Multipart progress tracking.","title":"Version 1.4.0"},{"location":"CHANGELOG/#version-130","text":"22-6-2020 Default read timeout in Methanol client. API for tracking upload/download progress. High-level client interceptors.","title":"Version 1.3.0"},{"location":"CHANGELOG/#version-120","text":"1-5-2020 Reactive JSON adapters with Jackson and Reactor. Common MediaType constants. XML adapters with JAXB.","title":"Version 1.2.0"},{"location":"CHANGELOG/#version-110","text":"17-4-2020 First \"main-stream\" release.","title":"Version 1.1.0"},{"location":"CHANGELOG/#version-100","text":"25-3-2020 Dummy release.","title":"Version 1.0.0"},{"location":"caching/","text":"Caching \u00b6 Methanol comes with an RFC-compliant HTTP cache that supports both disk & memory storage backends. Setup \u00b6 An HttpCache needs to know where it stores entries and how much space it can occupy. It is utilized by injecting it into a Methanol client. Disk // Select a size limit that suites your application long maxSizeInBytes = 500 * 1024 * 1024 ; // 500 MBs var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // Close the cache after you're done to ensure everything is flushed to disk cache . close (); Memory // Select a size limit that suites your application long maxSizeInBytes = 50 * 1024 * 1024 ; // 50 MBs var cache = HttpCache . newBuilder () . cacheOnMemory ( maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // No need to close, but doing so avoids surprises if you later switch to disk cache . close (); Hint You can pass the builder a custom Executor for launching asynchronous tasks needed by the cache. By default, an unbounded thread pool of non-daemon threads is used. Caution To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an IOException if it's initialized with a directory that's already in use by another instance in the same or a different JVM. Usage \u00b6 An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time & bandwidth by avoiding network if requested resources are locally retrievable. It does so while preserving the typical HTTP client-server semantics. Thus, it should be OK for modules to start using a cache-configured Methanol (and hence HttpClient ) instance as a drop-in replacement without further setup. Sometimes, however, you want to communicate to the cache certain conditions you want applied to how it behaves. This is done using CacheControl . CacheControl // Specify your cache directives var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofHours ( 10 )) . staleWhileRevalidate ( Duration . ofSeconds ( 30 )) . build (); // Apply the directives to your request var request = MutableRequest . GET ( \"...\" ) . cacheControl ( cacheControl ); Cache-Control header // Cache-Control headers work too var request = MutableRequest . GET ( \"...\" ) . header ( \"Cache-Control\" , \"max-age=36000\" , \"stale-while-revalidate=30\" ); In order to properly use CacheControl , we need to understand the key attributes of a cached response. Age \u00b6 The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the server. Freshness \u00b6 A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime . The freshness value of a response is its freshness lifetime subtracted from its age. A response is fresh if its freshness value is >= 0 . CacheControl lets you override a response's freshness lifetime by setting the max-age directive. var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofSeconds ( 10 )) // Override the lifetime set by the server, if any . build (); You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value. var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 10 )) // Accept a response that stays fresh for at least the next 10 minutes . build (); Info Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard & followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation & its last modification time for such response. Staleness \u00b6 Responses with negative freshness values are said to be stale. The staleness value of a stored response is simply its freshness value negated. Normally, the cache won't serve a stale response until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like If-None-Match & If-Modified-Since , if it can serve the stale response at its disposal. If the server doesn't mind, the cache serves said response without re-downloading its payload. Otherwise, the whole response is re-fetched. You can let the cache tolerate some stalness so it doesn't trigger revalidation. Bounded Staleness var cacheControl = CacheControl . newBuilder () . maxStale ( Duration . ofSeconds ( 30 )) // Allow at most 30 seconds of staleness . build (); Arbitrary Staleness var cacheControl = CacheControl . newBuilder () . anyMaxStale () // Allow any staleness . build (); The stale-if-error directive makes the cache recover from revalidation errors, caused by network or server failures. The cache falls back to responses with at most the specified staleness in such occasions. var cacheControl = CacheControl . newBuilder () . staleIfError ( Duration . ofSeconds ( 30 )) . build (); No Cache \u00b6 You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what no-cache is meant for. var cacheControl = CacheControl . newBuilder () . noCache () . build (); The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed. Only If Cached \u00b6 Use only-if-cached to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, however, the cache immediately serves a locally generated 504 Gateway Timeout response. var cacheControl = CacheControl . newBuilder () . onlyIfCached () . build (); A perfect use-case is when network is down or the app is offline. You'd want to get a cached response if it's there or otherwise nothing. Prohibiting Storage \u00b6 Use no-store if you don't want the cache to store anything about the response. var request = CacheControl . newBuilder () . noStore () . build (); Note that this, however, doesn't prohibit the cache from serving an already stored response. Asynchronous Revalidation \u00b6 Sometimes you need a balance between responsiveness & freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That's exactly what stale-while-revalidate does. If the directive is found on a stale response, the cache serves it immediately provided it satisfies allowed staleness. What's interesting is that an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh. Invalidation \u00b6 HttpCache has APIs that give you more control over what's stored. var cache = ... // Remove the entry cached under a particular URI cache . remove ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); // Remove the response matching a particular response variant cache . remove ( MutableRequest . GET ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )) . header ( \"Accept-Encoding\" , \"gzip\" )); // Remove specific entries by examining their URIs var iterator = cache . uris (); while ( iterator . hasNext ()) { var uri = iterator . next (); if ( uri . getHost (). equals ( \"i.imgur.com\" )) { iterator . remove (); } } // Remove all entries cache . clear (); // Dispose of the cache by deleting its entrires then closing it in an atomic fashion. // The cache is rendered unusable after this call. This is meant for applications that // use a temporary directory for caching in case persistence isn't needed. cache . dispose (); Cache Operation & Statistics \u00b6 The cache is accompanied by APIs that reflect its operation & effectiveness. Cache operation typically involves 3 scenarios. Cache Hit The blessed scenario; everything was entirely served from cache and no network was used. Conditional Cache Hit The cache had to contact the origin to revalidate its copy of the response and the server decided it was valid. The cache uses server's response to update some metadata in background. Response payload isn't downloaded so network is used efficiently. Cache Miss Either the cache had no matching response or the server decided such response is too stale to be server. In both cases, the whole response is fetched from network. This is when the cache populates or updates its entries if appropriate. CacheAwareResponse \u00b6 CacheAwareResponse complements HttpResponse to better reflect cache interference. If a cache is installed, any HttpResponse<T> returned by Methanol is also a CacheAwareResponse<T> , which you can use to know which of the previous scenarios was the case. var cache = ... var client = Methanol . newBuilder () . cache ( cache ) . build (); var response = ( CacheAwareResponse < String > ) client . send ( MutableRequest . GET ( url ), BodyHandlers . ofString ()); var timeElapsed = Duration . between ( response . timeRequestSent (), response . timeResponseReceived ()); System . out . println ( \"Time elapsed: \" + timeElapsed ); // networkResponse & cacheResponse are optional HttpResponses that you can further investigate var networkResponse = response . networkResponse (); var cacheResponse = response . cacheResponse (); switch ( response . cacheStatus ()) { case HIT : assertTrue ( networkResponse . isAbsent ()); assertTrue ( cacheResponse . isPresent ()); break ; case CONDITIONAL_HIT : assertTrue ( networkResponse . isPresent ()); assertTrue ( cacheResponse . isPresent ()); break ; case MISS : assertTrue ( networkResponse . isPresent ()); // cacheResponse can be absent or present break ; case LOCALLY_GENERATED : // Network was forbidden by only-if-cached but there was no valid cache response assertEquals ( HttpURLConnection . HTTP_GATEWAY_TIMEOUT , response . statusCode ()); assertTrue ( networkResponse . isAbsent ()); // cacheResponse can be absent or present break ; } HttpCache.Stats \u00b6 You can examine statistics provided by the cache to measure its effectiveness. Statistics are either global or correspond to a specific URI . Global Stats var stats = cache . stats (); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); URI-specific Stats var stats = cache . stats ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); See HttpCache.Stats for all recorded statistics. Limitations \u00b6 The cache only stores responses to GETs. This is typical for most caches. The cache never stores partial responses . Only the most recent response variant can be stored. Cache efficiency isn't pronounced as much if requests frequently have different values for the headers specified by Vary .","title":"Caching"},{"location":"caching/#caching","text":"Methanol comes with an RFC-compliant HTTP cache that supports both disk & memory storage backends.","title":"Caching"},{"location":"caching/#setup","text":"An HttpCache needs to know where it stores entries and how much space it can occupy. It is utilized by injecting it into a Methanol client. Disk // Select a size limit that suites your application long maxSizeInBytes = 500 * 1024 * 1024 ; // 500 MBs var cache = HttpCache . newBuilder () . cacheOnDisk ( Path . of ( \"my-cache-dir\" ), maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // Close the cache after you're done to ensure everything is flushed to disk cache . close (); Memory // Select a size limit that suites your application long maxSizeInBytes = 50 * 1024 * 1024 ; // 50 MBs var cache = HttpCache . newBuilder () . cacheOnMemory ( maxSizeInBytes ) . build (); // The cache intercepts requests you send through this client var client = Methanol . newBuilder () . cache ( cache ) . build (); // No need to close, but doing so avoids surprises if you later switch to disk cache . close (); Hint You can pass the builder a custom Executor for launching asynchronous tasks needed by the cache. By default, an unbounded thread pool of non-daemon threads is used. Caution To avoid surprises, make sure the disk directory is exclusively owned by a single cache instance as long as it's open and nothing else. The cache enforces that to some degree by complaining with an IOException if it's initialized with a directory that's already in use by another instance in the same or a different JVM.","title":"Setup"},{"location":"caching/#usage","text":"An HTTP cache is a transparent layer between you and the origin server. Its main goal is to save time & bandwidth by avoiding network if requested resources are locally retrievable. It does so while preserving the typical HTTP client-server semantics. Thus, it should be OK for modules to start using a cache-configured Methanol (and hence HttpClient ) instance as a drop-in replacement without further setup. Sometimes, however, you want to communicate to the cache certain conditions you want applied to how it behaves. This is done using CacheControl . CacheControl // Specify your cache directives var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofHours ( 10 )) . staleWhileRevalidate ( Duration . ofSeconds ( 30 )) . build (); // Apply the directives to your request var request = MutableRequest . GET ( \"...\" ) . cacheControl ( cacheControl ); Cache-Control header // Cache-Control headers work too var request = MutableRequest . GET ( \"...\" ) . header ( \"Cache-Control\" , \"max-age=36000\" , \"stale-while-revalidate=30\" ); In order to properly use CacheControl , we need to understand the key attributes of a cached response.","title":"Usage"},{"location":"caching/#age","text":"The age of a stored response is the time it has been resident in your cache or any other cache along the route to the origin. In other words, a response's age is the time evaluated since it was last generated by the server.","title":"Age"},{"location":"caching/#freshness","text":"A fresh response is one that is servable by the cache without contacting the origin. A server specifies how long a stored response stays fresh. This is known as the response's freshness lifetime . The freshness value of a response is its freshness lifetime subtracted from its age. A response is fresh if its freshness value is >= 0 . CacheControl lets you override a response's freshness lifetime by setting the max-age directive. var cacheControl = CacheControl . newBuilder () . maxAge ( Duration . ofSeconds ( 10 )) // Override the lifetime set by the server, if any . build (); You can specify how fresh you'd like the response to be by putting a lower bound on its freshness value. var cacheControl = CacheControl . newBuilder () . minFresh ( Duration . ofMinutes ( 10 )) // Accept a response that stays fresh for at least the next 10 minutes . build (); Info Sometimes, a response lacks an explicit freshness lifetime. As encouraged by the standard & followed by browsers, Methanol uses a heuristic of 10% of the time between a response's generation & its last modification time for such response.","title":"Freshness"},{"location":"caching/#staleness","text":"Responses with negative freshness values are said to be stale. The staleness value of a stored response is simply its freshness value negated. Normally, the cache won't serve a stale response until it's revalidated with the server. Revalidation causes the cache to ask the server, using special headers like If-None-Match & If-Modified-Since , if it can serve the stale response at its disposal. If the server doesn't mind, the cache serves said response without re-downloading its payload. Otherwise, the whole response is re-fetched. You can let the cache tolerate some stalness so it doesn't trigger revalidation. Bounded Staleness var cacheControl = CacheControl . newBuilder () . maxStale ( Duration . ofSeconds ( 30 )) // Allow at most 30 seconds of staleness . build (); Arbitrary Staleness var cacheControl = CacheControl . newBuilder () . anyMaxStale () // Allow any staleness . build (); The stale-if-error directive makes the cache recover from revalidation errors, caused by network or server failures. The cache falls back to responses with at most the specified staleness in such occasions. var cacheControl = CacheControl . newBuilder () . staleIfError ( Duration . ofSeconds ( 30 )) . build ();","title":"Staleness"},{"location":"caching/#no-cache","text":"You might want the cache to forward your request to origin even if there's a fresh stored response (e.g. refreshing a page). That's what no-cache is meant for. var cacheControl = CacheControl . newBuilder () . noCache () . build (); The cache will use network efficiently. If there's a stored response, its presence is communicated to the server, so it can decide to let the cache serve said response if nothing has changed.","title":"No Cache"},{"location":"caching/#only-if-cached","text":"Use only-if-cached to avoid network in all cases. As usual, a stored response is served if it's suitable. Otherwise, however, the cache immediately serves a locally generated 504 Gateway Timeout response. var cacheControl = CacheControl . newBuilder () . onlyIfCached () . build (); A perfect use-case is when network is down or the app is offline. You'd want to get a cached response if it's there or otherwise nothing.","title":"Only If Cached"},{"location":"caching/#prohibiting-storage","text":"Use no-store if you don't want the cache to store anything about the response. var request = CacheControl . newBuilder () . noStore () . build (); Note that this, however, doesn't prohibit the cache from serving an already stored response.","title":"Prohibiting Storage"},{"location":"caching/#asynchronous-revalidation","text":"Sometimes you need a balance between responsiveness & freshness. You are willing to get a response immediately even if it's stale, but ensure it is freshened for later access. That's exactly what stale-while-revalidate does. If the directive is found on a stale response, the cache serves it immediately provided it satisfies allowed staleness. What's interesting is that an asynchronous revalidation is triggered and the response is updated in background, keeping things fresh.","title":"Asynchronous Revalidation"},{"location":"caching/#invalidation","text":"HttpCache has APIs that give you more control over what's stored. var cache = ... // Remove the entry cached under a particular URI cache . remove ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); // Remove the response matching a particular response variant cache . remove ( MutableRequest . GET ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )) . header ( \"Accept-Encoding\" , \"gzip\" )); // Remove specific entries by examining their URIs var iterator = cache . uris (); while ( iterator . hasNext ()) { var uri = iterator . next (); if ( uri . getHost (). equals ( \"i.imgur.com\" )) { iterator . remove (); } } // Remove all entries cache . clear (); // Dispose of the cache by deleting its entrires then closing it in an atomic fashion. // The cache is rendered unusable after this call. This is meant for applications that // use a temporary directory for caching in case persistence isn't needed. cache . dispose ();","title":"Invalidation"},{"location":"caching/#cache-operation-statistics","text":"The cache is accompanied by APIs that reflect its operation & effectiveness. Cache operation typically involves 3 scenarios. Cache Hit The blessed scenario; everything was entirely served from cache and no network was used. Conditional Cache Hit The cache had to contact the origin to revalidate its copy of the response and the server decided it was valid. The cache uses server's response to update some metadata in background. Response payload isn't downloaded so network is used efficiently. Cache Miss Either the cache had no matching response or the server decided such response is too stale to be server. In both cases, the whole response is fetched from network. This is when the cache populates or updates its entries if appropriate.","title":"Cache Operation &amp; Statistics"},{"location":"caching/#cacheawareresponse","text":"CacheAwareResponse complements HttpResponse to better reflect cache interference. If a cache is installed, any HttpResponse<T> returned by Methanol is also a CacheAwareResponse<T> , which you can use to know which of the previous scenarios was the case. var cache = ... var client = Methanol . newBuilder () . cache ( cache ) . build (); var response = ( CacheAwareResponse < String > ) client . send ( MutableRequest . GET ( url ), BodyHandlers . ofString ()); var timeElapsed = Duration . between ( response . timeRequestSent (), response . timeResponseReceived ()); System . out . println ( \"Time elapsed: \" + timeElapsed ); // networkResponse & cacheResponse are optional HttpResponses that you can further investigate var networkResponse = response . networkResponse (); var cacheResponse = response . cacheResponse (); switch ( response . cacheStatus ()) { case HIT : assertTrue ( networkResponse . isAbsent ()); assertTrue ( cacheResponse . isPresent ()); break ; case CONDITIONAL_HIT : assertTrue ( networkResponse . isPresent ()); assertTrue ( cacheResponse . isPresent ()); break ; case MISS : assertTrue ( networkResponse . isPresent ()); // cacheResponse can be absent or present break ; case LOCALLY_GENERATED : // Network was forbidden by only-if-cached but there was no valid cache response assertEquals ( HttpURLConnection . HTTP_GATEWAY_TIMEOUT , response . statusCode ()); assertTrue ( networkResponse . isAbsent ()); // cacheResponse can be absent or present break ; }","title":"CacheAwareResponse"},{"location":"caching/#httpcachestats","text":"You can examine statistics provided by the cache to measure its effectiveness. Statistics are either global or correspond to a specific URI . Global Stats var stats = cache . stats (); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); URI-specific Stats var stats = cache . stats ( URI . create ( \"https://i.imgur.com/OBmbMPV.mp4\" )); System . out . println ( stats . hitRate ()); System . out . println ( stats . missRate ()); See HttpCache.Stats for all recorded statistics.","title":"HttpCache.Stats"},{"location":"caching/#limitations","text":"The cache only stores responses to GETs. This is typical for most caches. The cache never stores partial responses . Only the most recent response variant can be stored. Cache efficiency isn't pronounced as much if requests frequently have different values for the headers specified by Vary .","title":"Limitations"},{"location":"decompression/","text":"Response Decompression \u00b6 One caveat concerning Java's HTTP client is the lack of support for automatic response decompression. A workaround is to use an available InputStream decompressor (e.g. GZIPInputStream ) that matches response's Content-Encoding . However, such approach is invasive as it forces us to deal with InputStreams . The straightforward and recommended solution is to use Methanol's enhanced HTTP client , which gives you transparent response decompression for gzip & deflate out of the box. final Methanol client = Methanol . create (); < T > HttpResponse < T > get ( String url , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { // No need to worry about adding Accept-Encoding and // decompressing the response. The client does that for you! return client . send ( MutableRequest . GET ( url ), bodyHandler )); } Read on if you're interested in knowing how that's accomplished or you want to extend decompression support. Decoding BodyHandler \u00b6 The entry point to response body decompression is MoreBodyHandlers::decoding . This method takes your desired BodyHandler and gives you one that decompresses the response body as your handler's BodySubscriber receives it. var response = client . send ( request , MoreBodyHandlers . decoding ( BodyHandlers . ofString ())); The new BodyHandler intercepts the response, checking if there's a Content-Encoding header. If so, the body is decompressed accordingly, and your handler won't see any Content-Encoding or Content-Length headers. This is because they're outdated in that case. Otherwise, the handler acts as a no-op and delegates to your handler directly. Note that it doesn't matter which BodyHandler you're using; you can have whatever response body type you want. BodyDecoder \u00b6 A BodyDecoder is a BodySubscriber with the added semantics of a Flow.Processor . It intercepts the flow of bytes on its way down from the HTTP client, decoding each List<ByteBuffer> individually. The decoded bytes are forwarded to a downstream BodySubscriber , which converts them into the desired response body. A BodyDecoder.Factory associates itself with a defined encoding that's suitable as a Content-Encoding directive. Given a downstream BodySubscriber , the factory creates a BodyDecoder that forwards the response body after decoding it using the factory's encoding. For instance, a factory associated with gzip creates decoders that decompress the response using the gzip format . Factory Lookup \u00b6 Factories are installed as service-providers in the manner specified by Java's ServiceLoader . A decoding BodyHandler looks up a factory associated with response's Content-Encoding . If found, it's called to wrap user's BodySubscriber , so it receives the decompressed body. Otherwise, an UnsupportedOperationException is thrown. Supported Encodings \u00b6 The core module has support for gzip & deflate out of the box. There's also a separate module providing support for brotli . Extending decompression support \u00b6 Adding support for more encodings or overriding supported ones is a matter of writing a BodyDecoder implementation and providing a corresponding factory. However, implementing the decoder's Flow.Publisher semantics can be tricky. Instead, implement an AsyncDecoder and wrap in an AsyncBodyDecoder , so you're only concerned with your decompression logic. Writing an AsyncDecoder \u00b6 Decoding is done as a number of decode(source, sink) rounds finalized by one final round, each with the currently available input. After the final round, your AsyncDecoder must've completely exhausted its source. Here's a decoder implementation that uses jzlib for gzip & deflate decompression. class JZlibDecoder implements AsyncDecoder { private static final int BUFFER_SIZE = 8096 ; private final String encoding ; private final com . jcraft . jzlib . Inflater inflater ; private final ByteBuffer input = ByteBuffer . allocate ( BUFFER_SIZE ); private final ByteBuffer output = ByteBuffer . allocate ( BUFFER_SIZE ); JZlibDecoder ( String encoding , com . jcraft . jzlib . JZlib . WrapperType wrapperType ) { try { this . encoding = encoding ; inflater = new com . jcraft . jzlib . Inflater ( wrapperType ); inflater . setInput ( input . array ()); inflater . setOutput ( output . array ()); } catch ( com . jcraft . jzlib . GZIPException e ) { throw new RuntimeException ( e ); } } @Override public String encoding () { return encoding ; } @Override public void decode ( ByteSource source , ByteSink sink ) throws IOException { synchronized ( inflater ) { while ( source . hasRemaining ()) { // Prepare input for this iteration inflater . setNextInIndex ( 0 ); inflater . setAvailIn ( refillInput ( source )); // Continue inflating as long as there's more input or there's pending output boolean mightHavePendingOutput = false ; inflateLoop: while ( inflater . getAvailIn () > 0 || mightHavePendingOutput ) { // Prepare for new output inflater . setNextOutIndex ( 0 ); inflater . setAvailOut ( output . capacity ()); int status = inflater . inflate ( com . jcraft . jzlib . JZlib . Z_SYNC_FLUSH ); int outputCount = inflater . getNextOutIndex (); sink . pushBytes ( output . position ( 0 ). limit ( outputCount )); switch ( status ) { case com . jcraft . jzlib . JZlib . Z_OK : mightHavePendingOutput = inflater . getAvailOut () == 0 ; break ; case com . jcraft . jzlib . JZlib . Z_STREAM_END : // The compressed stream has ended break inflateLoop ; default: throw new IOException ( \"problem with zlib: \" + Integer . toHexString ( status )); } } } } } private int refillInput ( ByteSource source ) { // Pull as much bytes from the source as possible input . clear (); while ( source . hasRemaining () && input . hasRemaining ()) { source . pullBytes ( input ); } return input . flip (). limit (); } @Override public synchronized void close () { synchronized ( inflater ) { inflater . end (); } } } Registering a Factory \u00b6 Here's a BodyDecoder.Factory for gzip using our jzlib decoder. public static final class MyDecoderFactory implements BodyDecoder . Factory { @Override public String encoding () { return \"gzip\" ; } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream , Executor executor ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } } The next step is to declare your factory as a service-provider. For instance, here's an appropriate provides declaration to put in module-info.java if your application uses Java modules. module my . module { ... provides BodyDecoder . Factory with MyDecoderFactory ; }","title":"Decompression"},{"location":"decompression/#response-decompression","text":"One caveat concerning Java's HTTP client is the lack of support for automatic response decompression. A workaround is to use an available InputStream decompressor (e.g. GZIPInputStream ) that matches response's Content-Encoding . However, such approach is invasive as it forces us to deal with InputStreams . The straightforward and recommended solution is to use Methanol's enhanced HTTP client , which gives you transparent response decompression for gzip & deflate out of the box. final Methanol client = Methanol . create (); < T > HttpResponse < T > get ( String url , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { // No need to worry about adding Accept-Encoding and // decompressing the response. The client does that for you! return client . send ( MutableRequest . GET ( url ), bodyHandler )); } Read on if you're interested in knowing how that's accomplished or you want to extend decompression support.","title":"Response Decompression"},{"location":"decompression/#decoding-bodyhandler","text":"The entry point to response body decompression is MoreBodyHandlers::decoding . This method takes your desired BodyHandler and gives you one that decompresses the response body as your handler's BodySubscriber receives it. var response = client . send ( request , MoreBodyHandlers . decoding ( BodyHandlers . ofString ())); The new BodyHandler intercepts the response, checking if there's a Content-Encoding header. If so, the body is decompressed accordingly, and your handler won't see any Content-Encoding or Content-Length headers. This is because they're outdated in that case. Otherwise, the handler acts as a no-op and delegates to your handler directly. Note that it doesn't matter which BodyHandler you're using; you can have whatever response body type you want.","title":"Decoding BodyHandler"},{"location":"decompression/#bodydecoder","text":"A BodyDecoder is a BodySubscriber with the added semantics of a Flow.Processor . It intercepts the flow of bytes on its way down from the HTTP client, decoding each List<ByteBuffer> individually. The decoded bytes are forwarded to a downstream BodySubscriber , which converts them into the desired response body. A BodyDecoder.Factory associates itself with a defined encoding that's suitable as a Content-Encoding directive. Given a downstream BodySubscriber , the factory creates a BodyDecoder that forwards the response body after decoding it using the factory's encoding. For instance, a factory associated with gzip creates decoders that decompress the response using the gzip format .","title":"BodyDecoder"},{"location":"decompression/#factory-lookup","text":"Factories are installed as service-providers in the manner specified by Java's ServiceLoader . A decoding BodyHandler looks up a factory associated with response's Content-Encoding . If found, it's called to wrap user's BodySubscriber , so it receives the decompressed body. Otherwise, an UnsupportedOperationException is thrown.","title":"Factory Lookup"},{"location":"decompression/#supported-encodings","text":"The core module has support for gzip & deflate out of the box. There's also a separate module providing support for brotli .","title":"Supported Encodings"},{"location":"decompression/#extending-decompression-support","text":"Adding support for more encodings or overriding supported ones is a matter of writing a BodyDecoder implementation and providing a corresponding factory. However, implementing the decoder's Flow.Publisher semantics can be tricky. Instead, implement an AsyncDecoder and wrap in an AsyncBodyDecoder , so you're only concerned with your decompression logic.","title":"Extending decompression support"},{"location":"decompression/#writing-an-asyncdecoder","text":"Decoding is done as a number of decode(source, sink) rounds finalized by one final round, each with the currently available input. After the final round, your AsyncDecoder must've completely exhausted its source. Here's a decoder implementation that uses jzlib for gzip & deflate decompression. class JZlibDecoder implements AsyncDecoder { private static final int BUFFER_SIZE = 8096 ; private final String encoding ; private final com . jcraft . jzlib . Inflater inflater ; private final ByteBuffer input = ByteBuffer . allocate ( BUFFER_SIZE ); private final ByteBuffer output = ByteBuffer . allocate ( BUFFER_SIZE ); JZlibDecoder ( String encoding , com . jcraft . jzlib . JZlib . WrapperType wrapperType ) { try { this . encoding = encoding ; inflater = new com . jcraft . jzlib . Inflater ( wrapperType ); inflater . setInput ( input . array ()); inflater . setOutput ( output . array ()); } catch ( com . jcraft . jzlib . GZIPException e ) { throw new RuntimeException ( e ); } } @Override public String encoding () { return encoding ; } @Override public void decode ( ByteSource source , ByteSink sink ) throws IOException { synchronized ( inflater ) { while ( source . hasRemaining ()) { // Prepare input for this iteration inflater . setNextInIndex ( 0 ); inflater . setAvailIn ( refillInput ( source )); // Continue inflating as long as there's more input or there's pending output boolean mightHavePendingOutput = false ; inflateLoop: while ( inflater . getAvailIn () > 0 || mightHavePendingOutput ) { // Prepare for new output inflater . setNextOutIndex ( 0 ); inflater . setAvailOut ( output . capacity ()); int status = inflater . inflate ( com . jcraft . jzlib . JZlib . Z_SYNC_FLUSH ); int outputCount = inflater . getNextOutIndex (); sink . pushBytes ( output . position ( 0 ). limit ( outputCount )); switch ( status ) { case com . jcraft . jzlib . JZlib . Z_OK : mightHavePendingOutput = inflater . getAvailOut () == 0 ; break ; case com . jcraft . jzlib . JZlib . Z_STREAM_END : // The compressed stream has ended break inflateLoop ; default: throw new IOException ( \"problem with zlib: \" + Integer . toHexString ( status )); } } } } } private int refillInput ( ByteSource source ) { // Pull as much bytes from the source as possible input . clear (); while ( source . hasRemaining () && input . hasRemaining ()) { source . pullBytes ( input ); } return input . flip (). limit (); } @Override public synchronized void close () { synchronized ( inflater ) { inflater . end (); } } }","title":"Writing an AsyncDecoder"},{"location":"decompression/#registering-a-factory","text":"Here's a BodyDecoder.Factory for gzip using our jzlib decoder. public static final class MyDecoderFactory implements BodyDecoder . Factory { @Override public String encoding () { return \"gzip\" ; } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } @Override public < T > BodyDecoder < T > create ( BodySubscriber < T > downstream , Executor executor ) { return new AsyncBodyDecoder <> ( new JZlibDecoder ( \"gzip\" , com . jcraft . jzlib . JZlib . WrapperType . GZIP ), downstream ); } } The next step is to declare your factory as a service-provider. For instance, here's an appropriate provides declaration to put in module-info.java if your application uses Java modules. module my . module { ... provides BodyDecoder . Factory with MyDecoderFactory ; }","title":"Registering a Factory"},{"location":"enhanced_httpclient/","text":"Enhanced HttpClient \u00b6 Methanol has a special HttpClient that extends the standard one with interesting new features. Unsurprisingly, the client is named Methanol . Usage \u00b6 In addition to interceptors and caching , Methanol can apply default properties to your requests. Think resolving with a base URI, adding default request headers, default timeouts, etc. var builder = Methanol . newBuilder () . cache (...) . interceptor (...) . userAgent ( \"Will Smith\" ) // Custom User-Agent . baseUri ( \"https://api.github.com\" ) // Base URI to resolve requests' URI against . defaultHeader ( \"Accept\" , \"application/json\" ) // Default request headers . requestTimeout ( Duration . ofSeconds ( 20 )) // Default request timeout . readTimeout ( Duration . ofSeconds ( 5 )) // Timeout for single reads . autoAcceptEncoding ( true ); // Transparent response compression, this is true by default // Continue using as a standard HttpClient.Builder! var client = builder . executor (...) . executor ( Executors . newFixedThreadPool ( 16 )) . connectTimeout ( Duration . ofSeconds ( 30 )) ... . build (); You can also build from an existing HttpClient instance. Note that you can't install an HttpCache in such case. HttpClient prebuiltClient = ... var client = Methanol . newBuilder ( prebuiltClient ) . interceptor (...) . userAgent ( \"Will Smith\" ) ... . build (); Tip Methanol is an HttpClient . It implements the same API like send & sendAsync , which you can continue using as usual. Note Default properties don't override those the request already has. For instance, a client with a default Accept: text/html will not override a request's Accept: application/json . Transparent Compression \u00b6 If autoAcceptEncoding is enabled, the client complements requests with an Accept-Encoding header which accepts all supported encodings (i.e. available BodyDecoder providers). Additionally, the response is transparently decompressed according to its Content-Encoding . Since deflate & gzip are supported out of the box, they're always included in Accept-Encoding . For instance, if brotli is installed, requests will typically have: Accept-Encoding: deflate, gzip, br . If you want specific encodings to be applied, add Accept-Encoding as a default header or explicitly set one in your request. Default Header // Advertise brotli decompression var client = Methanol . newBuilder () . defaultHeader ( \"Accept-Encoding\" , \"br\" ) . build (); Request Header // Advertise brotli decompression var request = MutableRequest . GET ( uri ) . header ( \"Accept-Encoding\" , \"br\" ); MimeBodyPublisher \u00b6 Methanol automatically sets a request's Content-Type if it has a MimeBodyPublisher . If the request already has a Content-Type , it's overwritten. This makes sense as a body knows its media type better than a containing request mistakenly setting a different one. Reactive Dispatching \u00b6 If you like reactive streams, use Methanol::exchange , which is like sendAsync but returns Publisher<HttpResponse<T>> sources instead. Without HTTP/2 Push var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com/?nopush\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" ))); JdkFlowAdapters . flowPublisherToFlux ( publisher ) . subscribe ( response -> System . out . println ( \"%s: %s\" , response , response . body ())) . blockLast (); With HTTP/2 Push var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" )), pushPromise -> BodyHandlers . ofFile ( Path . of ( pushPromise . uri (). getPath ()). getFileName ())); JdkFlowAdapters . flowPublisherToFlux ( publisher ) . subscribe ( response -> System . out . println ( \"%s: %s\" , response , response . body ())) . blockLast (); MutableRequest \u00b6 MutableRequest is an HttpRequest that implements HttpRequest.Builder for settings request's properties. This drops immutability in favor of some convenience when the request is sent immediately. var response = client . send ( MutableReqeust . GET ( uri ), BodyHandlers . ofString ()); Additionally, MutableRequest accepts relative URIs (standard HttpRequest.Builder doesn't). This is a complementing feature to Methanol 's base URIs, against which relative ones are resolved. Tip You can use MutableRequest::toImmutableRequest to get an immutable HttpRequest snapshot.","title":"HttpClient++"},{"location":"enhanced_httpclient/#enhanced-httpclient","text":"Methanol has a special HttpClient that extends the standard one with interesting new features. Unsurprisingly, the client is named Methanol .","title":"Enhanced HttpClient"},{"location":"enhanced_httpclient/#usage","text":"In addition to interceptors and caching , Methanol can apply default properties to your requests. Think resolving with a base URI, adding default request headers, default timeouts, etc. var builder = Methanol . newBuilder () . cache (...) . interceptor (...) . userAgent ( \"Will Smith\" ) // Custom User-Agent . baseUri ( \"https://api.github.com\" ) // Base URI to resolve requests' URI against . defaultHeader ( \"Accept\" , \"application/json\" ) // Default request headers . requestTimeout ( Duration . ofSeconds ( 20 )) // Default request timeout . readTimeout ( Duration . ofSeconds ( 5 )) // Timeout for single reads . autoAcceptEncoding ( true ); // Transparent response compression, this is true by default // Continue using as a standard HttpClient.Builder! var client = builder . executor (...) . executor ( Executors . newFixedThreadPool ( 16 )) . connectTimeout ( Duration . ofSeconds ( 30 )) ... . build (); You can also build from an existing HttpClient instance. Note that you can't install an HttpCache in such case. HttpClient prebuiltClient = ... var client = Methanol . newBuilder ( prebuiltClient ) . interceptor (...) . userAgent ( \"Will Smith\" ) ... . build (); Tip Methanol is an HttpClient . It implements the same API like send & sendAsync , which you can continue using as usual. Note Default properties don't override those the request already has. For instance, a client with a default Accept: text/html will not override a request's Accept: application/json .","title":"Usage"},{"location":"enhanced_httpclient/#transparent-compression","text":"If autoAcceptEncoding is enabled, the client complements requests with an Accept-Encoding header which accepts all supported encodings (i.e. available BodyDecoder providers). Additionally, the response is transparently decompressed according to its Content-Encoding . Since deflate & gzip are supported out of the box, they're always included in Accept-Encoding . For instance, if brotli is installed, requests will typically have: Accept-Encoding: deflate, gzip, br . If you want specific encodings to be applied, add Accept-Encoding as a default header or explicitly set one in your request. Default Header // Advertise brotli decompression var client = Methanol . newBuilder () . defaultHeader ( \"Accept-Encoding\" , \"br\" ) . build (); Request Header // Advertise brotli decompression var request = MutableRequest . GET ( uri ) . header ( \"Accept-Encoding\" , \"br\" );","title":"Transparent Compression"},{"location":"enhanced_httpclient/#mimebodypublisher","text":"Methanol automatically sets a request's Content-Type if it has a MimeBodyPublisher . If the request already has a Content-Type , it's overwritten. This makes sense as a body knows its media type better than a containing request mistakenly setting a different one.","title":"MimeBodyPublisher"},{"location":"enhanced_httpclient/#reactive-dispatching","text":"If you like reactive streams, use Methanol::exchange , which is like sendAsync but returns Publisher<HttpResponse<T>> sources instead. Without HTTP/2 Push var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com/?nopush\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" ))); JdkFlowAdapters . flowPublisherToFlux ( publisher ) . subscribe ( response -> System . out . println ( \"%s: %s\" , response , response . body ())) . blockLast (); With HTTP/2 Push var client = Methanol . create (); var request = MutableRequest . GET ( \"https://http2-push.appspot.com\" ); var publisher = client . exchange ( request , BodyHandlers . ofFile ( Path . of ( \"page.html\" )), pushPromise -> BodyHandlers . ofFile ( Path . of ( pushPromise . uri (). getPath ()). getFileName ())); JdkFlowAdapters . flowPublisherToFlux ( publisher ) . subscribe ( response -> System . out . println ( \"%s: %s\" , response , response . body ())) . blockLast ();","title":"Reactive Dispatching"},{"location":"enhanced_httpclient/#mutablerequest","text":"MutableRequest is an HttpRequest that implements HttpRequest.Builder for settings request's properties. This drops immutability in favor of some convenience when the request is sent immediately. var response = client . send ( MutableReqeust . GET ( uri ), BodyHandlers . ofString ()); Additionally, MutableRequest accepts relative URIs (standard HttpRequest.Builder doesn't). This is a complementing feature to Methanol 's base URIs, against which relative ones are resolved. Tip You can use MutableRequest::toImmutableRequest to get an immutable HttpRequest snapshot.","title":"MutableRequest"},{"location":"interceptors/","text":"Interceptors \u00b6 Interceptors allow you to inspect, mutate, retry and short-circuit HTTP calls. Together, interceptors build an invocation chain that's capable of applying powerful transformations to requests moving forward and to responses in their way back. Writing Interceptors \u00b6 Interceptors sit between a Methanol client and its underlying HttpClient , referred to as its backend. When registered, an interceptor is invoked each send or sendAsync call. Here's an interceptor that logs requests and their responses. public final class LoggingInterceptor implements Methanol . Interceptor { private static final Logger LOGGER = Logger . getLogger ( LoggingInterceptor . class . getName ()); @Override public < T > HttpResponse < T > intercept ( HttpRequest request , Chain < T > chain ) throws IOException , InterruptedException { logRequest ( request ); return toLoggingChain ( request , chain ). forward ( request ); } @Override public < T > CompletableFuture < HttpResponse < T >> interceptAsync ( HttpRequest request , Chain < T > chain ) { logRequest ( request ); return toLoggingChain ( request , chain ). forwardAsync ( request ); } private static void logRequest ( HttpRequest request ) { LOGGER . info (() -> String . format ( \"Sending %s%n%s\" , request , headersToString ( request . headers ()))); } private static < T > Chain < T > toLoggingChain ( HttpRequest request , Chain < T > chain ) { var sentAt = Instant . now (); return chain . withBodyHandler ( responseInfo -> { LOGGER . info (() -> String . format ( \"Completed %s %s with %d in %sms%n%s\" , request . method (), request . uri (), responseInfo . statusCode (), Duration . between ( sentAt , Instant . now ()). toMillis (), headersToString ( responseInfo . headers ()))); // Apply the original BodyHandler return chain . bodyHandler (). apply ( responseInfo ); }); } private static String headersToString ( HttpHeaders headers ) { return headers . map (). entrySet (). stream () . map ( entry -> entry . getKey () + \": \" + String . join ( \", \" , entry . getValue ())) . collect ( Collectors . joining ( System . lineSeparator ())); } } HttpClient has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a Chain<T> so it can forward requests to its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's forward or forwardAsync after it has done its job. If your interceptor only modifies requests, prefer passing a lambda to Interceptor::create . // Enable 'Expect: Continue' for all POSTs to a particular host var expectContinueInterceptor = Interceptor . create ( request -> request . method (). equalsIgnoreCase ( \"POST\" ) && request . uri (). getHost (). equals ( \"api.imgur.com\" ) ? MutableRequest . copyOf ( request ). expectContinue ( true ) : request ); Intercepting Bodies \u00b6 A powerful property of interceptors is their control over how responses are received by their caller. An interceptor can transform its chain's BodyHandler using Chain::withBodyHandler before it forwards requests. A transformed BodyHandler typically applies the handler the chain previously had, then wraps the resulted BodySubscriber , so it intercepts the response body as it's being received by the caller. This is how Methanol does transparent decompression & cache writes. Note that this applies to requests too. You can transform a request body by wrapping its BodyPublisher , if it's got any. BodyPublisher & BodySubscriber APIs can be nicely layered to apply different transformations. Invocation Order \u00b6 An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and Methanol 's internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between Methanol and its backend HttpClient . They get invoked right before the request gets sent. This has a number of implications. Client Interceptors \u00b6 See the request just as received from the application. Their transformed BodyHandler receives the response body after the client applies its decompressing & cache writing handlers. Backend Interceptors \u00b6 Observe the request after the client applies things like the base URI and default headers. Additionally, they see intermediate headers added by the client or the cache like Accept-Encoding & If-None-Math . Receive the response body just as transmitted by the backend. For instance, a transformed BodyHandler receives a compressed body if the response comes with a Content-Encoding header. May not always be invoked. This is the case when a cache decides it doesn't need network and hence doesn't proceed the call to the backend. Attention If a cache is installed, Methanol does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors may be invoked more than once in the presence of a cache. Registration \u00b6 You can register client and backend interceptors with interceptor(...) and backendInterceptor(...) respectively. Interceptors in each group get invoked in registration order. Client Interceptors var client = Methanol . newBuilder () . interceptor ( new LoggingInterceptor ()) . build (); Backend Interceptors var client = Methanol . newBuilder () . backendInterceptor ( new LoggingInterceptor ()) . build (); Short-circuiting \u00b6 Both client & backend interceptors can refrain from forwarding a request. They're allowed to short-circuit a request's path by returning a fabricated response. This makes them good candidates for testing. You can mock responses with client interceptors to investigate requests just as sent by your application. Moreover, responses can be mocked with backend interceptors to explore requests as they get sent. This makes backend interceptors suitable for testing how your application interacts with the cache. Limitations \u00b6 Remember that Methanol is built atop a standard HttpClient , which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because HttpClient exports no API to do so.","title":"Interceptors"},{"location":"interceptors/#interceptors","text":"Interceptors allow you to inspect, mutate, retry and short-circuit HTTP calls. Together, interceptors build an invocation chain that's capable of applying powerful transformations to requests moving forward and to responses in their way back.","title":"Interceptors"},{"location":"interceptors/#writing-interceptors","text":"Interceptors sit between a Methanol client and its underlying HttpClient , referred to as its backend. When registered, an interceptor is invoked each send or sendAsync call. Here's an interceptor that logs requests and their responses. public final class LoggingInterceptor implements Methanol . Interceptor { private static final Logger LOGGER = Logger . getLogger ( LoggingInterceptor . class . getName ()); @Override public < T > HttpResponse < T > intercept ( HttpRequest request , Chain < T > chain ) throws IOException , InterruptedException { logRequest ( request ); return toLoggingChain ( request , chain ). forward ( request ); } @Override public < T > CompletableFuture < HttpResponse < T >> interceptAsync ( HttpRequest request , Chain < T > chain ) { logRequest ( request ); return toLoggingChain ( request , chain ). forwardAsync ( request ); } private static void logRequest ( HttpRequest request ) { LOGGER . info (() -> String . format ( \"Sending %s%n%s\" , request , headersToString ( request . headers ()))); } private static < T > Chain < T > toLoggingChain ( HttpRequest request , Chain < T > chain ) { var sentAt = Instant . now (); return chain . withBodyHandler ( responseInfo -> { LOGGER . info (() -> String . format ( \"Completed %s %s with %d in %sms%n%s\" , request . method (), request . uri (), responseInfo . statusCode (), Duration . between ( sentAt , Instant . now ()). toMillis (), headersToString ( responseInfo . headers ()))); // Apply the original BodyHandler return chain . bodyHandler (). apply ( responseInfo ); }); } private static String headersToString ( HttpHeaders headers ) { return headers . map (). entrySet (). stream () . map ( entry -> entry . getKey () + \": \" + String . join ( \", \" , entry . getValue ())) . collect ( Collectors . joining ( System . lineSeparator ())); } } HttpClient has blocking and asynchronous APIs, so interceptors must implement two methods matching each. An interceptor is given a Chain<T> so it can forward requests to its next sibling, or to the backend in case there's no more interceptors in the chain. The backend is where requests finally get sent. Typically, an interceptor calls its chain's forward or forwardAsync after it has done its job. If your interceptor only modifies requests, prefer passing a lambda to Interceptor::create . // Enable 'Expect: Continue' for all POSTs to a particular host var expectContinueInterceptor = Interceptor . create ( request -> request . method (). equalsIgnoreCase ( \"POST\" ) && request . uri (). getHost (). equals ( \"api.imgur.com\" ) ? MutableRequest . copyOf ( request ). expectContinue ( true ) : request );","title":"Writing Interceptors"},{"location":"interceptors/#intercepting-bodies","text":"A powerful property of interceptors is their control over how responses are received by their caller. An interceptor can transform its chain's BodyHandler using Chain::withBodyHandler before it forwards requests. A transformed BodyHandler typically applies the handler the chain previously had, then wraps the resulted BodySubscriber , so it intercepts the response body as it's being received by the caller. This is how Methanol does transparent decompression & cache writes. Note that this applies to requests too. You can transform a request body by wrapping its BodyPublisher , if it's got any. BodyPublisher & BodySubscriber APIs can be nicely layered to apply different transformations.","title":"Intercepting Bodies"},{"location":"interceptors/#invocation-order","text":"An interceptor can be either a client or a backend interceptor. Client interceptors sit between the application and Methanol 's internal interceptors. They are called as soon as the client receives a request. Backend interceptors sit between Methanol and its backend HttpClient . They get invoked right before the request gets sent. This has a number of implications.","title":"Invocation Order"},{"location":"interceptors/#client-interceptors","text":"See the request just as received from the application. Their transformed BodyHandler receives the response body after the client applies its decompressing & cache writing handlers.","title":"Client Interceptors"},{"location":"interceptors/#backend-interceptors","text":"Observe the request after the client applies things like the base URI and default headers. Additionally, they see intermediate headers added by the client or the cache like Accept-Encoding & If-None-Math . Receive the response body just as transmitted by the backend. For instance, a transformed BodyHandler receives a compressed body if the response comes with a Content-Encoding header. May not always be invoked. This is the case when a cache decides it doesn't need network and hence doesn't proceed the call to the backend. Attention If a cache is installed, Methanol does automatic redirection by itself, which would otherwise be done by the backend. This allows redirects to be cached, increasing cache efficiency. As a consequence, backend interceptors may be invoked more than once in the presence of a cache.","title":"Backend Interceptors"},{"location":"interceptors/#registration","text":"You can register client and backend interceptors with interceptor(...) and backendInterceptor(...) respectively. Interceptors in each group get invoked in registration order. Client Interceptors var client = Methanol . newBuilder () . interceptor ( new LoggingInterceptor ()) . build (); Backend Interceptors var client = Methanol . newBuilder () . backendInterceptor ( new LoggingInterceptor ()) . build ();","title":"Registration"},{"location":"interceptors/#short-circuiting","text":"Both client & backend interceptors can refrain from forwarding a request. They're allowed to short-circuit a request's path by returning a fabricated response. This makes them good candidates for testing. You can mock responses with client interceptors to investigate requests just as sent by your application. Moreover, responses can be mocked with backend interceptors to explore requests as they get sent. This makes backend interceptors suitable for testing how your application interacts with the cache.","title":"Short-circuiting"},{"location":"interceptors/#limitations","text":"Remember that Methanol is built atop a standard HttpClient , which can perform its own redirects, retries and other intermediate requests like authentications. These aren't interceptable. That's because HttpClient exports no API to do so.","title":"Limitations"},{"location":"interruptible_reading/","text":"Interruptible Reading \u00b6 Reading from blocking sources like InputStream isn't always avoidable. Once they're needed, JDK's BodyHandlers::ofInputStream can be used to obtain an HttpResponse<InputStream> . However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels . These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore. MoreBodySubscibers has interruptible ReadableByteChannel and Reader implementations. Use JDK's Channels::newInputStream to get an InputStream from an interruptible ReadableByteChannel when input streams is what you need. Example - Interruptible Body Processing \u00b6 Here's an example of a hypothetical component that processes the response from a ReadableByteChannel . When the task is to be discarded, reader threads are interrupted by shutting down the owning ExecutorService . This closes open channels and instructs them to halt blocking reads. class BodyProcessor { final ExecutorService executorService = Executors . newCachedThreadPool (); final Methanol client = Methanol . create (); CompletableFuture < Void > processAsync ( HttpRequest request , Consumer < ByteBuffer > processAction ) { return client . sendAsync ( request , MoreBodyHandlers . ofByteChannel ()) . thenApplyAsync ( res -> { var buffer = ByteBuffer . allocate ( 8 * 1024 ); try ( var channel = res . body ()) { while ( channel . read ( buffer . clear ()) >= 0 ) { processAction . accept ( buffer . flip ()); } } catch ( ClosedByInterruptException | ClosedChannelException ignored ) { // The thread was interrupted due to ExecutorService shutdown } catch ( IOException e ) { throw new UncheckedIOException ( e ); } return null ; }, executorService ); } void terminate () { executorService . shutdownNow (); } }","title":"Interruptible Reading"},{"location":"interruptible_reading/#interruptible-reading","text":"Reading from blocking sources like InputStream isn't always avoidable. Once they're needed, JDK's BodyHandlers::ofInputStream can be used to obtain an HttpResponse<InputStream> . However, reading from such stream blocks your threads indefinitely, which causes troubles when you want to close the application or change contexts amid reading. Methanol has support for interruptible channels . These are asynchronously closeable and respond to thread interrupts. Using them, you can voluntarily halt reading operations when they're not relevant anymore. MoreBodySubscibers has interruptible ReadableByteChannel and Reader implementations. Use JDK's Channels::newInputStream to get an InputStream from an interruptible ReadableByteChannel when input streams is what you need.","title":"Interruptible Reading"},{"location":"interruptible_reading/#example-interruptible-body-processing","text":"Here's an example of a hypothetical component that processes the response from a ReadableByteChannel . When the task is to be discarded, reader threads are interrupted by shutting down the owning ExecutorService . This closes open channels and instructs them to halt blocking reads. class BodyProcessor { final ExecutorService executorService = Executors . newCachedThreadPool (); final Methanol client = Methanol . create (); CompletableFuture < Void > processAsync ( HttpRequest request , Consumer < ByteBuffer > processAction ) { return client . sendAsync ( request , MoreBodyHandlers . ofByteChannel ()) . thenApplyAsync ( res -> { var buffer = ByteBuffer . allocate ( 8 * 1024 ); try ( var channel = res . body ()) { while ( channel . read ( buffer . clear ()) >= 0 ) { processAction . accept ( buffer . flip ()); } } catch ( ClosedByInterruptException | ClosedChannelException ignored ) { // The thread was interrupted due to ExecutorService shutdown } catch ( IOException e ) { throw new UncheckedIOException ( e ); } return null ; }, executorService ); } void terminate () { executorService . shutdownNow (); } }","title":"Example - Interruptible Body Processing"},{"location":"media_types/","text":"Mime \u00b6 Media types are the web's notion for file extensions. They're typically present in requests and responses as Content-Type directives. Methanol's MediaType greatly facilitates the representation and manipulation of media types. MediaType \u00b6 You can create a MediaType from its individual components or parse one from a Content-Type string. MediaType::of var applicationJsonUtf8 = MediaType . of ( \"application\" , \"json\" , Map . of ( \"charset\" , \"UTF-8\" )); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ()); MediaType::parse var applicationJsonUtf8 = MediaType . parse ( \"application/json; charset=UTF-8\" ); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ()); Media Ranges \u00b6 A MediaType also defines a media range to which one or more media types belong, including itself. var anyTextType = MediaType . parse ( \"text/*\" ); var textHtml = MediaType . parse ( \"text/html\" ); var applicationJson = MediaType . parse ( \"application/json\" ); assertTrue ( anyTextType . hasWildcard ()); assertTrue ( anyTextType . includes ( textHtml )); assertFalse ( anyTextType . includes ( applicationJson )); assertTrue ( anyTextType . isCompatibleWith ( textHtml )); assertTrue ( textHtml . isCompatibleWith ( anyTextType )); Tip MediaType has static definitions for the most popular media types & ranges. None of them, however, defines a charset parameter. You can use MediaType::withCharset to derive media types with charsets from the statically defined ones. static final MediaType APPLICATION_JSON_UTF8 = MediaType . APPLICATION_JSON . withCharset ( StandardCharsets . UTF_8 ); MimeBodyPublisher \u00b6 MimeBodyPublisher is a mixin-style interface that associates a MediaType with a BodyPublisher . It's recognized by Methanol and multipart bodies in that they get the appropriate Content-Type header implicitly added. You can adapt an arbitrary BodyPublisher into a MimeBodyPublisher . Here's a factory method that creates MimeBodyPublihers for files. The file's media type is probed from the system, falling back to application/octet-stream if that doesn't work. static MimeBodyPublisher ofMimeFile ( Path file ) throws FileNotFoundException { MediaType mediaType = null ; try { var contentType = Files . probeContentType ( file ); if ( contentType != null ) { mediaType = MediaType . parse ( contentType ); } } catch ( IOException ignored ) { } return MoreBodyPublishers . ofMediaType ( BodyPublishers . ofFile ( file ), requireNonNullElse ( mediaType , MediaType . APPLICATION_OCTET_STREAM )); } final Methanol client = Methanol . create (); < T > HttpResponse < T > post ( String url , Path file , BodyHandler < T > handler ) throws IOException , InterruptedException { // Request's Content-Type is implicitly added return client . send ( MutableRequest . POST ( url , ofMimeFile ( file )), handler ); }","title":"Meida Types"},{"location":"media_types/#mime","text":"Media types are the web's notion for file extensions. They're typically present in requests and responses as Content-Type directives. Methanol's MediaType greatly facilitates the representation and manipulation of media types.","title":"Mime"},{"location":"media_types/#mediatype","text":"You can create a MediaType from its individual components or parse one from a Content-Type string. MediaType::of var applicationJsonUtf8 = MediaType . of ( \"application\" , \"json\" , Map . of ( \"charset\" , \"UTF-8\" )); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ()); MediaType::parse var applicationJsonUtf8 = MediaType . parse ( \"application/json; charset=UTF-8\" ); assertEquals ( \"application\" , applicationJsonUtf8 . type ()); assertEquals ( \"json\" , applicationJsonUtf8 . subtype ()); assertEquals ( \"utf-8\" , applicationJsonUtf8 . parameters (). get ( \"charset\" )); assertEquals ( Optional . of ( StandardCharsets . UTF_8 ), applicationJsonUtf8 . charset ());","title":"MediaType"},{"location":"media_types/#media-ranges","text":"A MediaType also defines a media range to which one or more media types belong, including itself. var anyTextType = MediaType . parse ( \"text/*\" ); var textHtml = MediaType . parse ( \"text/html\" ); var applicationJson = MediaType . parse ( \"application/json\" ); assertTrue ( anyTextType . hasWildcard ()); assertTrue ( anyTextType . includes ( textHtml )); assertFalse ( anyTextType . includes ( applicationJson )); assertTrue ( anyTextType . isCompatibleWith ( textHtml )); assertTrue ( textHtml . isCompatibleWith ( anyTextType )); Tip MediaType has static definitions for the most popular media types & ranges. None of them, however, defines a charset parameter. You can use MediaType::withCharset to derive media types with charsets from the statically defined ones. static final MediaType APPLICATION_JSON_UTF8 = MediaType . APPLICATION_JSON . withCharset ( StandardCharsets . UTF_8 );","title":"Media Ranges"},{"location":"media_types/#mimebodypublisher","text":"MimeBodyPublisher is a mixin-style interface that associates a MediaType with a BodyPublisher . It's recognized by Methanol and multipart bodies in that they get the appropriate Content-Type header implicitly added. You can adapt an arbitrary BodyPublisher into a MimeBodyPublisher . Here's a factory method that creates MimeBodyPublihers for files. The file's media type is probed from the system, falling back to application/octet-stream if that doesn't work. static MimeBodyPublisher ofMimeFile ( Path file ) throws FileNotFoundException { MediaType mediaType = null ; try { var contentType = Files . probeContentType ( file ); if ( contentType != null ) { mediaType = MediaType . parse ( contentType ); } } catch ( IOException ignored ) { } return MoreBodyPublishers . ofMediaType ( BodyPublishers . ofFile ( file ), requireNonNullElse ( mediaType , MediaType . APPLICATION_OCTET_STREAM )); } final Methanol client = Methanol . create (); < T > HttpResponse < T > post ( String url , Path file , BodyHandler < T > handler ) throws IOException , InterruptedException { // Request's Content-Type is implicitly added return client . send ( MutableRequest . POST ( url , ofMimeFile ( file )), handler ); }","title":"MimeBodyPublisher"},{"location":"multipart_and_forms/","text":"Multipart & Forms \u00b6 Methanol has special BodyPublisher implementations for multipart uploads & form submission. Multipart Bodies \u00b6 MultipartBodyPublisher implements the flexible multipart format. A multipart body has one or more parts. Each part has a BodyPublisher for its content and HttpHeaders that describe it. MultipartBodyPublisher.Builder defaults to multipart/form-data if a multipart MediaType isn't explicitly specified. There're special methods for adding parts with a Content-Disposition: form-data header generated from a field name and an optional file name. These are referred to as form parts. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one. static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadGif () throws IOException , InterruptedException { var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , \"Dancing stick bug\" ) . filePart ( \"image\" , Path . of ( \"dancing-stick-bug.gif\" ), MediaType . IMAGE_GIF ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } If filePart isn't given a MediaType , it asks the system for one using the given Path , falling back to applciation/octet-stream if that doesn't work. Hint A part's Content-Type is automatically added if it's created with a MimeBodyPublisher . Generic Form Parts \u00b6 Use the builder's formPart method to add a form part from an arbitrary BodyPublisher . It takes a field name and an optional file name. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadPng ( String title , InputStream pngImageInputStream ) throws IOException , InterruptedException { var imagePart = MoreBodyPublishers . ofMediaType ( BodyPublishers . ofInputStream (() -> pngImageInputStream ), MediaType . IMAGE_PNG ); var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , title ) . formPart ( \"image\" , title + \".png\" , imagePart ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } Tip Use formPart to add a file part from something that's not a Path (e.g. InputStream ) or to override the part's filename property, which is not possible with filePart . Form Bodies \u00b6 Use FormBodyPublisher to send form data as a set of URL-encoded queries. Data is added as string name-value pairs. final Methanol client = Methanol . newBuilder () . followRedirects ( HttpClient . Redirect . NORMAL ) . build (); HttpResponse < Path > downloadArticle ( String title ) throws IOException , InterruptedException { var formBody = FormBodyPublisher . newBuilder () . query ( \"search\" , title ) . build (); var request = MutableRequest . POST ( \"https://en.wikipedia.org/wiki/Main_Page\" , searchQuery ); return client . send ( request , BodyHandlers . ofFile ( Path . of ( title + \".html\" ))); } Hint Requests with MultipartBodyPublisher or FormBodyPublisher will have their Content-Type header added automatically if sent on a Methanol client.","title":"Multipart & Forms"},{"location":"multipart_and_forms/#multipart-forms","text":"Methanol has special BodyPublisher implementations for multipart uploads & form submission.","title":"Multipart &amp; Forms"},{"location":"multipart_and_forms/#multipart-bodies","text":"MultipartBodyPublisher implements the flexible multipart format. A multipart body has one or more parts. Each part has a BodyPublisher for its content and HttpHeaders that describe it. MultipartBodyPublisher.Builder defaults to multipart/form-data if a multipart MediaType isn't explicitly specified. There're special methods for adding parts with a Content-Disposition: form-data header generated from a field name and an optional file name. These are referred to as form parts. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one. static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadGif () throws IOException , InterruptedException { var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , \"Dancing stick bug\" ) . filePart ( \"image\" , Path . of ( \"dancing-stick-bug.gif\" ), MediaType . IMAGE_GIF ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } If filePart isn't given a MediaType , it asks the system for one using the given Path , falling back to applciation/octet-stream if that doesn't work. Hint A part's Content-Type is automatically added if it's created with a MimeBodyPublisher .","title":"Multipart Bodies"},{"location":"multipart_and_forms/#generic-form-parts","text":"Use the builder's formPart method to add a form part from an arbitrary BodyPublisher . It takes a field name and an optional file name. // Substitute with your client ID. Visit https://api.imgur.com/oauth2/addclient to get one static final String CLIENT_ID = System . getenv ( \"IMGUR_CLIENT_ID\" ); final Methanol client = Methanol . create (); HttpResponse < String > uploadPng ( String title , InputStream pngImageInputStream ) throws IOException , InterruptedException { var imagePart = MoreBodyPublishers . ofMediaType ( BodyPublishers . ofInputStream (() -> pngImageInputStream ), MediaType . IMAGE_PNG ); var multipartBody = MultipartBodyPublisher . newBuilder () . textPart ( \"title\" , title ) . formPart ( \"image\" , title + \".png\" , imagePart ) . build (); var request = MutableRequest . POST ( \"https://api.imgur.com/3/image\" , multipartBody ) . header ( \"Authorization\" , \"Client-ID \" + CLIENT_ID ); return client . send ( request , BodyHandlers . ofString ()); } Tip Use formPart to add a file part from something that's not a Path (e.g. InputStream ) or to override the part's filename property, which is not possible with filePart .","title":"Generic Form Parts"},{"location":"multipart_and_forms/#form-bodies","text":"Use FormBodyPublisher to send form data as a set of URL-encoded queries. Data is added as string name-value pairs. final Methanol client = Methanol . newBuilder () . followRedirects ( HttpClient . Redirect . NORMAL ) . build (); HttpResponse < Path > downloadArticle ( String title ) throws IOException , InterruptedException { var formBody = FormBodyPublisher . newBuilder () . query ( \"search\" , title ) . build (); var request = MutableRequest . POST ( \"https://en.wikipedia.org/wiki/Main_Page\" , searchQuery ); return client . send ( request , BodyHandlers . ofFile ( Path . of ( title + \".html\" ))); } Hint Requests with MultipartBodyPublisher or FormBodyPublisher will have their Content-Type header added automatically if sent on a Methanol client.","title":"Form Bodies"},{"location":"object_mapping/","text":"Object Mapping \u00b6 HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available BodyPublisher & BodySubscriber implementations are too basic, and implementing your own can be tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies. Setup \u00b6 Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules. methanol-gson : JSON with Gson methanol-jackson : JSON with Jackson methanol-jackson-flux : Reactive JSON with Jackson and Reactor methanol-protobuf : Google's Protocol Buffers methanol-jaxb : XML with JAXB Adapters are dynamically located using Java's ServiceLoader . You can find clear installation steps in each module's README. We'll later see how to implement custom adapters as well. If you want to run examples presented here, get started by installing your favorite JSON adapter! Receiving Objects \u00b6 To get an HttpResponse<T> , give MoreBodyHandlers a T.class and it'll give you a BodyHandler<T> in return. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofObject ( GitHubUser . class )); return response . body (); } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted } If you want to get fancier with generics, use a TypeRef<T> . List < GitHubIssue > getIssuesForRepo ( String owner , String repo ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"repos/\" + owner + \"/\" + repo \"/issues\" ); var response = client . send ( request , MoreBodyHandlers . ofObject ( new TypeRef < List < GitHubIssue >> () {})); return response . body (); } public static final class GitHubIssue { public String title ; public GitHubUser user ; public String body ; // Other fields omitted } The right adapter is selected based on response's Content-Type . For instance, a response with Content-Type: application/json causes Methanol to look for a JSON adapter. If such lookup fails, an UnsupportedOperationException is thrown. Sending Objects \u00b6 Get a BodyPubilsher for whatever object you've got by passing it in along with a MediaType describing which adapter you prefer selected. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . build (); String renderMarkdown ( RenderRequest renderRequest ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( renderRequest , MediaType . APPLICATION_JSON ); var request = MutableRequest . POST ( \"/user/\" + username , requestBody ) . header ( \"Accept\" , \"application/html\" ); var response = client . send ( request , BodyHandlers . ofString ()); return response . body (); } public static final class RenderRequest { public String text , mode , context ; } Adapters \u00b6 An adapter provides Encoder and/or Decoder implementations. Both interfaces implement BodyAdapter , which defines the methods necessary for Methanol to know which object types the adapter believes it can handle, and in what scheme. An Encoder creates a BodyPublisher that streams a given object's serialized form. Similarly, a Decoder supplies BodySubscriber<T> instances for a given TypeRef<T> that convert the response body into T . An optional MediaType is passed to encoders & decoders to further describe the desired mapping scheme (e.g. specify a character set). Example - An HTML Adapter \u00b6 Here's an adapter that uses Jsoup to convert HTML bodies to parsed Document objects and vise versa. When you're writing adapters, extend from AbstractBodyAdapter to get free media type matching & other helpful functions. public abstract class JsoupAdapter extends AbstractBodyAdapter implements BodyAdapter { JsoupAdapter () { super ( MediaType . TEXT_HTML ); } @Override public boolean supportsType ( TypeRef <?> type ) { return type . rawType () == Document . class ; } public static final class Decoder extends JsoupAdapter implements BodyAdapter . Decoder { @Override public < T > BodySubscriber < T > toObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var subscriber = BodySubscribers . mapping ( BodySubscribers . ofString ( charset ), Jsoup :: parse ); return BodySubscribers . mapping ( subscriber , type . exactRawType ():: cast ); // Safely cast Document to T } } public static final class Encoder extends JsoupAdapter implements BodyAdapter . Encoder { @Override public BodyPublisher toBody ( Object object , @Nullable MediaType mediaType ) { requireSupport ( object . getClass ()); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var publisher = BodyPublishers . ofString ((( Document ) object ). outerHtml (), charset ); return attachMediaType ( pubisher , mediaType ); } } } Tip Make sure your encoders call AbstractBodyAdapter::attachMediaType so the created BodyPublisher is converted to a MimeBodyPublisher if the given media type isn't null. That way, requests get the correct Content-Type header added by Methanol . Registration \u00b6 Declare your encoder & decoder implementations as service-providers in the manner specified by Java's ServiceLoader . Here's the appropriate provider declarations for our Jsoup adapter to put in module-info.java . module my . module { ... provides BodyAdapter . Decoder with JsoupAdapter . Decoder ; provides BodyAdapter . Encoder with JsoupAdapter . Encoder ; } Usage \u00b6 Now Methanol can send and receive HTML Documents ! final Methanol client = Methanol . create (); HttpResponse < Document > downloadHtml ( String url ) IOException , InterruptedException { var request = MutableRequest . GET ( url ) . header ( \"Accept\" , \"application/html\" ); return client . send ( request , MoreBodyHandlers . ofObject ( Document . class )); } < T > HttpResponse < T > uploadHtml ( String url , Document htmlDoc , BodyHandler < T > responseHandler ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( htmlDoc , MediaType . TEXT_HTML ); var request = MutableRequest . POST ( url , requestBody ); return client . send ( request , responseHandler ); } Buffering vs Streaming \u00b6 MoreBodyHandlers::ofObject creates handlers that use MoreBodySubscribers::ofObject to obtain the appropriate BodySubscriber<T> from a chosen adapter. Such subscriber typically loads the whole response into memory then decodes from there. If your responses tend to have large bodies, or you'd prefer the memory efficiency afforded by streaming sources, MoreBodyHandlers::ofDeferredObject is the way to go. GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofDeferredObject ( GitHubUser . class )); return response . body (). get (); } The handler results in an HttpResponse<Supplier<T>> . The response is completed as soon as all headers are read. If the chosen decoder's toDeferredObject is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an InputStream or a Reader . The Decoder interface has a naive default implementation for toDeferredObject that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder. @Override public < T > BodySubscriber < Supplier < T >> toDeferredObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); BodySubscriber < Supplier < Document >> subscriber = BodySubscribers . mapping ( MoreBodySubscribers . ofReader ( charset ), reader -> () -> Parser . htmlParser (). parseInput ( reader , \"\" )); // Note the deferred parsing return BodySubscribers . mapping ( subscriber , supplier -> () -> type . exactRawType (). cast ( supplier . get ())); // Safely cast Document to T }","title":"Object Mapping"},{"location":"object_mapping/#object-mapping","text":"HTTP bodies are often mappable to high-level entities that your code understands. Java's HttpClient was designed with that in mind. However, available BodyPublisher & BodySubscriber implementations are too basic, and implementing your own can be tricky. Methanol builds upon these APIs with an extensible and easy-to-use object mapping mechanism that treats your objects as first-citizen HTTP bodies.","title":"Object Mapping"},{"location":"object_mapping/#setup","text":"Before sending and receiving objects over HTTP, Methanol needs to adapt to your desired mapping schemes. Adapters for the most popular serialization libraries are provided in separate modules. methanol-gson : JSON with Gson methanol-jackson : JSON with Jackson methanol-jackson-flux : Reactive JSON with Jackson and Reactor methanol-protobuf : Google's Protocol Buffers methanol-jaxb : XML with JAXB Adapters are dynamically located using Java's ServiceLoader . You can find clear installation steps in each module's README. We'll later see how to implement custom adapters as well. If you want to run examples presented here, get started by installing your favorite JSON adapter!","title":"Setup"},{"location":"object_mapping/#receiving-objects","text":"To get an HttpResponse<T> , give MoreBodyHandlers a T.class and it'll give you a BodyHandler<T> in return. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . defaultHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofObject ( GitHubUser . class )); return response . body (); } public static final class GitHubUser { public String login ; public long id ; public String url ; // Other fields omitted } If you want to get fancier with generics, use a TypeRef<T> . List < GitHubIssue > getIssuesForRepo ( String owner , String repo ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"repos/\" + owner + \"/\" + repo \"/issues\" ); var response = client . send ( request , MoreBodyHandlers . ofObject ( new TypeRef < List < GitHubIssue >> () {})); return response . body (); } public static final class GitHubIssue { public String title ; public GitHubUser user ; public String body ; // Other fields omitted } The right adapter is selected based on response's Content-Type . For instance, a response with Content-Type: application/json causes Methanol to look for a JSON adapter. If such lookup fails, an UnsupportedOperationException is thrown.","title":"Receiving Objects"},{"location":"object_mapping/#sending-objects","text":"Get a BodyPubilsher for whatever object you've got by passing it in along with a MediaType describing which adapter you prefer selected. final Methanol client = Methanol . newBuilder () . baseUri ( \"https://api.github.com\" ) . build (); String renderMarkdown ( RenderRequest renderRequest ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( renderRequest , MediaType . APPLICATION_JSON ); var request = MutableRequest . POST ( \"/user/\" + username , requestBody ) . header ( \"Accept\" , \"application/html\" ); var response = client . send ( request , BodyHandlers . ofString ()); return response . body (); } public static final class RenderRequest { public String text , mode , context ; }","title":"Sending Objects"},{"location":"object_mapping/#adapters","text":"An adapter provides Encoder and/or Decoder implementations. Both interfaces implement BodyAdapter , which defines the methods necessary for Methanol to know which object types the adapter believes it can handle, and in what scheme. An Encoder creates a BodyPublisher that streams a given object's serialized form. Similarly, a Decoder supplies BodySubscriber<T> instances for a given TypeRef<T> that convert the response body into T . An optional MediaType is passed to encoders & decoders to further describe the desired mapping scheme (e.g. specify a character set).","title":"Adapters"},{"location":"object_mapping/#example-an-html-adapter","text":"Here's an adapter that uses Jsoup to convert HTML bodies to parsed Document objects and vise versa. When you're writing adapters, extend from AbstractBodyAdapter to get free media type matching & other helpful functions. public abstract class JsoupAdapter extends AbstractBodyAdapter implements BodyAdapter { JsoupAdapter () { super ( MediaType . TEXT_HTML ); } @Override public boolean supportsType ( TypeRef <?> type ) { return type . rawType () == Document . class ; } public static final class Decoder extends JsoupAdapter implements BodyAdapter . Decoder { @Override public < T > BodySubscriber < T > toObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var subscriber = BodySubscribers . mapping ( BodySubscribers . ofString ( charset ), Jsoup :: parse ); return BodySubscribers . mapping ( subscriber , type . exactRawType ():: cast ); // Safely cast Document to T } } public static final class Encoder extends JsoupAdapter implements BodyAdapter . Encoder { @Override public BodyPublisher toBody ( Object object , @Nullable MediaType mediaType ) { requireSupport ( object . getClass ()); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); var publisher = BodyPublishers . ofString ((( Document ) object ). outerHtml (), charset ); return attachMediaType ( pubisher , mediaType ); } } } Tip Make sure your encoders call AbstractBodyAdapter::attachMediaType so the created BodyPublisher is converted to a MimeBodyPublisher if the given media type isn't null. That way, requests get the correct Content-Type header added by Methanol .","title":"Example - An HTML Adapter"},{"location":"object_mapping/#registration","text":"Declare your encoder & decoder implementations as service-providers in the manner specified by Java's ServiceLoader . Here's the appropriate provider declarations for our Jsoup adapter to put in module-info.java . module my . module { ... provides BodyAdapter . Decoder with JsoupAdapter . Decoder ; provides BodyAdapter . Encoder with JsoupAdapter . Encoder ; }","title":"Registration"},{"location":"object_mapping/#usage","text":"Now Methanol can send and receive HTML Documents ! final Methanol client = Methanol . create (); HttpResponse < Document > downloadHtml ( String url ) IOException , InterruptedException { var request = MutableRequest . GET ( url ) . header ( \"Accept\" , \"application/html\" ); return client . send ( request , MoreBodyHandlers . ofObject ( Document . class )); } < T > HttpResponse < T > uploadHtml ( String url , Document htmlDoc , BodyHandler < T > responseHandler ) throws IOException , InterruptedException { var requestBody = MoreBodyPublishers . ofObject ( htmlDoc , MediaType . TEXT_HTML ); var request = MutableRequest . POST ( url , requestBody ); return client . send ( request , responseHandler ); }","title":"Usage"},{"location":"object_mapping/#buffering-vs-streaming","text":"MoreBodyHandlers::ofObject creates handlers that use MoreBodySubscribers::ofObject to obtain the appropriate BodySubscriber<T> from a chosen adapter. Such subscriber typically loads the whole response into memory then decodes from there. If your responses tend to have large bodies, or you'd prefer the memory efficiency afforded by streaming sources, MoreBodyHandlers::ofDeferredObject is the way to go. GitHubUser getUser ( String username ) throws IOException , InterruptedException { var request = MutableRequest . GET ( \"/user/\" + username ); var response = client . send ( request , MoreBodyHandlers . ofDeferredObject ( GitHubUser . class )); return response . body (). get (); } The handler results in an HttpResponse<Supplier<T>> . The response is completed as soon as all headers are read. If the chosen decoder's toDeferredObject is implemented correctly, processing is deferred till you invoke the supplier and the body is decoded from a streaming source, typically an InputStream or a Reader . The Decoder interface has a naive default implementation for toDeferredObject that doesn't read from a streaming source. Here's how it'd be properly implemented for our HTML adapter's decoder. @Override public < T > BodySubscriber < Supplier < T >> toDeferredObject ( TypeRef < T > type , @Nullable MediaType mediaType ) { requireSupport ( type ); requireCompatibleOrNull ( mediaType ); var charset = charsetOrUtf8 ( mediaType ); BodySubscriber < Supplier < Document >> subscriber = BodySubscribers . mapping ( MoreBodySubscribers . ofReader ( charset ), reader -> () -> Parser . htmlParser (). parseInput ( reader , \"\" )); // Note the deferred parsing return BodySubscribers . mapping ( subscriber , supplier -> () -> type . exactRawType (). cast ( supplier . get ())); // Safely cast Document to T }","title":"Buffering vs Streaming"},{"location":"progress_tracking/","text":"Progress Tracking \u00b6 You can track download & upload progress using Methanol's ProgressTracker . Setup \u00b6 A ProgressTracker controls the rate at which progress events are propagated using two thresholds: bytes transferred & time passed, both calculated since the last event. Byte count threshold // Receive a progress event at least each 50 kBs of data var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . build (); Time passed threshold // Receive a progress event at least each half a second var tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofSeconds ( 1 ). divideBy ( 2 )) . build (); Tip You can use the builder to set an Executor that's used for dispatching progress events to your listener. That's useful in case your listener does something like GUI updates. You'd want it to be invoked in the GUI thread rather than an arbitrary HTTP client thread. var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . executor ( javafx . application . Platform :: runLater ) . build (); Usage \u00b6 You track download progress by attaching a Listener to a response's BodyHandler . Similarly, upload progress is tracked by registering a Listener with a request's BodyPublisher . Track downloads final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofMillis ( 100 )) . build (); HttpResponse < Path > downloadVeryInterestingVideo () throws IOException , InterruptedException { var request = MutableReqeust . GET ( \"https://i.imgur.com/OBmbMPV.mp4\" ); var downloadingBodyHandler = BodyHandlers . ofFile ( Path . of ( \"interesting-video.mp4\" ), CREATE , WRITE ); var trackingBodyHandler = tracker . tracking ( downloadingBodyHandler , this :: onProgress ); return client . send ( request , trackingBodyHandler ); } void onProgress ( Progress progress ) { if ( progress . done ()) { System . out . println ( \"Done!\" ); } else if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); var roundedPercent = Math . round ( 100 * percent ) / 100.0 ; System . out . printf ( \"Downloaded %d from %d (%d)%n\" , progress . bytesTransferred (), progress . contentLength (), roundedPercent ); } else { System . out . println ( \"Downloaded \" + progress . bytesTransferred ()); } } Track uploads final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofMillis ( 100 )) . build (); < T > HttpResponse < T > upload ( Path file , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { var trackingRequestBody = tracker . tracking ( BodyPublishers . ofFile ( file ), this :: onProgress ); var request = MutableReqeust . POST ( \"https://httpbin.org/post\" , trackingRequestBody ); return client . send ( request , bodyHandler ); } void onProgress ( Progress progress ) { if ( progress . done ()) { System . out . println ( \"Done!\" ); } if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); var roundedPercent = Math . round ( 100 * percent ) / 100.0 ; System . out . printf ( \"Uploaded %d from %d (%d)%n\" , progress . bytesTransferred (), progress . contentLength (), roundedPercent ); } else { System . out . println ( \"Uploaded \" + progress . bytesTransferred ()); } } Tip By default, the tracker doesn't fire 0% and 100% progress events. You can enable builder's enclosedProgress option to receive these. That way, you're notified when downloads or uploads begin or end.","title":"Progress Tracking"},{"location":"progress_tracking/#progress-tracking","text":"You can track download & upload progress using Methanol's ProgressTracker .","title":"Progress Tracking"},{"location":"progress_tracking/#setup","text":"A ProgressTracker controls the rate at which progress events are propagated using two thresholds: bytes transferred & time passed, both calculated since the last event. Byte count threshold // Receive a progress event at least each 50 kBs of data var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . build (); Time passed threshold // Receive a progress event at least each half a second var tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofSeconds ( 1 ). divideBy ( 2 )) . build (); Tip You can use the builder to set an Executor that's used for dispatching progress events to your listener. That's useful in case your listener does something like GUI updates. You'd want it to be invoked in the GUI thread rather than an arbitrary HTTP client thread. var tracker = ProgressTracker . newBuilder () . bytesTransferredThreshold ( 50 * 1024 ) . executor ( javafx . application . Platform :: runLater ) . build ();","title":"Setup"},{"location":"progress_tracking/#usage","text":"You track download progress by attaching a Listener to a response's BodyHandler . Similarly, upload progress is tracked by registering a Listener with a request's BodyPublisher . Track downloads final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofMillis ( 100 )) . build (); HttpResponse < Path > downloadVeryInterestingVideo () throws IOException , InterruptedException { var request = MutableReqeust . GET ( \"https://i.imgur.com/OBmbMPV.mp4\" ); var downloadingBodyHandler = BodyHandlers . ofFile ( Path . of ( \"interesting-video.mp4\" ), CREATE , WRITE ); var trackingBodyHandler = tracker . tracking ( downloadingBodyHandler , this :: onProgress ); return client . send ( request , trackingBodyHandler ); } void onProgress ( Progress progress ) { if ( progress . done ()) { System . out . println ( \"Done!\" ); } else if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); var roundedPercent = Math . round ( 100 * percent ) / 100.0 ; System . out . printf ( \"Downloaded %d from %d (%d)%n\" , progress . bytesTransferred (), progress . contentLength (), roundedPercent ); } else { System . out . println ( \"Downloaded \" + progress . bytesTransferred ()); } } Track uploads final Methanol client = Methanol . create (); final ProgressTracker tracker = ProgressTracker . newBuilder () . timePassedThreshold ( Duration . ofMillis ( 100 )) . build (); < T > HttpResponse < T > upload ( Path file , BodyHandler < T > bodyHandler ) throws IOException , InterruptedException { var trackingRequestBody = tracker . tracking ( BodyPublishers . ofFile ( file ), this :: onProgress ); var request = MutableReqeust . POST ( \"https://httpbin.org/post\" , trackingRequestBody ); return client . send ( request , bodyHandler ); } void onProgress ( Progress progress ) { if ( progress . done ()) { System . out . println ( \"Done!\" ); } if ( progress . determinate ()) { // Overall progress can be measured var percent = 100 * progress . value (); var roundedPercent = Math . round ( 100 * percent ) / 100.0 ; System . out . printf ( \"Uploaded %d from %d (%d)%n\" , progress . bytesTransferred (), progress . contentLength (), roundedPercent ); } else { System . out . println ( \"Uploaded \" + progress . bytesTransferred ()); } } Tip By default, the tracker doesn't fire 0% and 100% progress events. You can enable builder's enclosedProgress option to receive these. That way, you're notified when downloads or uploads begin or end.","title":"Usage"},{"location":"writablebodypublisher/","text":"WritableBodyPublisher \u00b6 Using WritableBodyPublisher , you can stream the request body through an OutputStream or a WritableByteChannel , possibly asynchronously. Example - Gzipped Uploads \u00b6 Let's say your sever supports compressed requests. You'd want your file uploads to be faster, so you compress the request body with gzip. final Methanol client = Methanol . create (); CompletableFuture < HttpResponse < Void >> postAsync ( Path file ) { var requestBody = WritableBodyPublisher . create (); var request = MutableRequest . POST ( \"https://example.com\" , requestBody ) . header ( \"Content-Encoding\" , \"gzip\" ); CompletableFuture . runAsync (() -> { try ( var gzipOut = new GZIPOutputStream ( requestBody . outputStream ())) { Files . copy ( file , gzipOut ); } catch ( IOException ioe ) { requestBody . closeExceptionally ( ioe ); } }); return client . sendAsync ( request , BodyHandlers . discarding ()); } WritableBodyPublisher acts as a pipe which connects OutputStream and BodyPublisher backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use WritableBodyPublisher::flush to make any buffered content available for consumption. After you're done writing, call close() or closeExceptionally(Throwable) to complete the request either normally or exceptionally.","title":"WritableBodyPublisher"},{"location":"writablebodypublisher/#writablebodypublisher","text":"Using WritableBodyPublisher , you can stream the request body through an OutputStream or a WritableByteChannel , possibly asynchronously.","title":"WritableBodyPublisher"},{"location":"writablebodypublisher/#example-gzipped-uploads","text":"Let's say your sever supports compressed requests. You'd want your file uploads to be faster, so you compress the request body with gzip. final Methanol client = Methanol . create (); CompletableFuture < HttpResponse < Void >> postAsync ( Path file ) { var requestBody = WritableBodyPublisher . create (); var request = MutableRequest . POST ( \"https://example.com\" , requestBody ) . header ( \"Content-Encoding\" , \"gzip\" ); CompletableFuture . runAsync (() -> { try ( var gzipOut = new GZIPOutputStream ( requestBody . outputStream ())) { Files . copy ( file , gzipOut ); } catch ( IOException ioe ) { requestBody . closeExceptionally ( ioe ); } }); return client . sendAsync ( request , BodyHandlers . discarding ()); } WritableBodyPublisher acts as a pipe which connects OutputStream and BodyPublisher backends. It may buffer content temporarily in case the consumer can't keep up with the producer, or till an inner buffer becomes full. You can use WritableBodyPublisher::flush to make any buffered content available for consumption. After you're done writing, call close() or closeExceptionally(Throwable) to complete the request either normally or exceptionally.","title":"Example - Gzipped Uploads"}]}